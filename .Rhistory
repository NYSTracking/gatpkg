big.mark = ",", scientific=FALSE), "*",
ratevars$numerator, "/", ratevars$denominator))
if (exclist$var1 != "NONE") {
gats$sub <- paste(gats$sub, "\nExclusion criteria: ",
exclist$var1, exclist$math1,
format(exclist$val1, big.mark=",", scientific=FALSE))
}
if (exclist$var2 != "NONE") {
gats$sub <- paste(gats$sub, ";", exclist$var2, exclist$math2,
format(exclist$val2, big.mark=",", scientific=FALSE))
}
if (exclist$var3 != "NONE") {
gats$sub <- paste(gats$sub, ";", exclist$var3, exclist$math3,
format(exclist$val3, big.mark=",", scientific=FALSE))
}
myplots$rate <- plotGATmaps(area = myshps$aggregated, var = ratevars$ratename,
clr = ratevars$colorscheme,
title.sub = gats$sub,
title.main = gats$title, ratemap = TRUE,
mapstats = TRUE)
} # end mapping new rate
# 12. save old shapefile ####
step <- step + 1
pb <- list(title = "NYSDOH GAT: saving files",
label = paste("Writing the original shapfile to",
paste0(filevars$fileout, "in")))
tcltk::setTkProgressBar(tpb, value = step, title = pb$title, label = pb$label)
# create crosswalk of old and new ids
myshps$crosswalk <- myshps$original
myshps$crosswalk@data <- cbind(myshps$original@data,
data.frame(GATid = aggvars$IDlist))
# warnings don't make sense; they say data not written successfully,
# but shapefile is fine and data match original file
rgdal::writeOGR(myshps$crosswalk, filevars$pathout,
paste0(filevars$fileout, "in"),
driver = "ESRI Shapefile", verbose = TRUE,
overwrite_layer = TRUE)
# 13. save new shapefile ####
step <- step + 1
pb$label = paste("Writing the merged shapfile to", filevars$fileout)
tcltk::setTkProgressBar(tpb, value = step, title = pb$title, label = pb$label)
names(myshps$compact@data) <- substr(names(myshps$compact@data), 1, 10)
ratevars$ratename <- substr(ratevars$ratename, 1, 10)
# export the map as a shapefile
rgdal::writeOGR(myshps$compact, filevars$pathout,
filevars$fileout, driver = "ESRI Shapefile",
verbose = TRUE, overwrite_layer = TRUE)
# large areas throw warnings that appear unfounded
# 14. save maps to pdf ####
step <- step + 1
pb$label = paste0("Writing the plots to ", filevars$fileout, "plots.pdf.")
tcltk::setTkProgressBar(tpb, value = step, title = pb$title,
label = pb$label)
# save the plots to a pdf file
pdf(paste0(filevars$userout, "plots.pdf"), onefile=TRUE, width = 10,
height = 7)
for (myplot in myplots) {
if (class(myplot) == "recordedplot") replayPlot(myplot)
} # only saves plots that exist
dev.off() # need to close pdf file
rm(myplots)
# 15. save kml file ####
if (gatvars$savekml==TRUE) { # now includes descriptions
step <- step + 1
pb$label = "Writing the KML file."
tcltk::setTkProgressBar(tpb, value = step, title = pb$title,
label = pb$label)
writeGATkml(myshp = myshps$compact, filename = filevars$fileout,
filepath = filevars$pathout, myidvar = gatvars$myidvar)
}
# 16. save log file ####
step <- step + 1
pb$label = paste0("Writing the log to ",
paste0(filevars$fileout, ".log"), ".")
tcltk::setTkProgressBar(tpb, value = step, title = pb$title, label = pb$label)
mysettings$exists = file.exists(paste0(filevars$userout, ".shp"))
# include projection? number of aggregations? rate calculations?
# recode to read in lists (or pre-create chunks) instead of individual values?
writeGATlog(gatvars = gatvars, aggvars = aggvars, filevars = filevars,
mysettings = mysettings, area = myshps$original,
mergevars = mergevars, ratevars = ratevars, exclist = exclist)
step <- step + 1
pb$label = "GAT is finished."
tcltk::setTkProgressBar(tpb, value = 27, title = pb$title, label = pb$label)
# save relevant objects
save(file = paste0(filevars$userout, "settings.Rdata"),
list = c("gatvars", "aggvars", "filevars", "mergevars", "ratevars",
"exclist"))
if (mysettings$exists) {
msg <- paste0("NYS GAT is finished. Your files were saved to ",
filevars$pathout,
". \nPlease see the log file for more details.")
tcltk::tkmessageBox(title = "GAT finished", type = "ok",
icon = "info", message = msg)
msg <- paste0("\n\nThe following files have been written to the folder \n",
filevars$pathout, ": \n  ",
filevars$fileout, ".dbf \n  ",
filevars$fileout, ".prj \n  ",
filevars$fileout, ".shp \n  ",
filevars$fileout, ".shx \n  ",
filevars$fileout, "in.dbf \n  ",
filevars$fileout, "in.prj \n  ",
filevars$fileout, "in.shp \n  ",
filevars$fileout, "in.shx \n  ",
filevars$fileout, "plots.pdf \n  ",
filevars$fileout, ".log \n  ",
filevars$fileout, "settings.Rdata \n  ")
if (gatvars$savekml==TRUE) msg <- paste0(msg, filevars$fileout, ".kml \n")
msg <- paste0(msg, "\nSee the log file for more details.")
message(msg)
} else {
# the shapefile failed to write
msg <- "Something went wrong. Your shapefiles were not saved."
tcltk::tkmessageBox(title = "Shapefile save failed", type = "ok",
icon = "error", message = msg)
}
} else {
# "else" occurs only if GAT is cancelled in the input phase
# there are now redundant warnings; function-level are commented out
msg <- "You have chosen to cancel GAT."
tcltk::tkmessageBox(title = "GAT cancelled",
message = msg,
type = "ok", icon = "warning")
}
# end GAT ####
close(tpb)
}
defineGATmerge_minfirst <- function(area, gatvars, mergevars, filevars,
pwrepeat = FALSE,
adjacent = TRUE, minfirst = FALSE) {
# temp until it's programmed in ####
if (!"GATflag" %in% names(area@data)) {
area@data$GATflag <- 0 # for non-default uses of this function
}
if (gatvars$aggregator2 == "NONE") {
gatvars$aggregator2 <- gatvars$aggregator1
}
max1 <- as.numeric(gsub(",", "", gatvars$maxvalue1))
min1 <- as.numeric(gsub(",", "", gatvars$minvalue1))
max2 <- as.numeric(gsub(",", "", gatvars$maxvalue2))
min2 <- as.numeric(gsub(",", "", gatvars$minvalue2))
# draw progress bar ####
mb <- list(label = "Preparing merge files. Please wait.",
title = "NYSDOH GAT: merging")
tmb <- tcltk::tkProgressBar(title = mb$title, label = mb$label, min = 0,
max = nrow(area@data), initial = 0, width = 400)
# if projection is lat/lon, projection = TRUE, otherwise FALSE
mapvars <- list(projection = grepl("longlat",
sp::proj4string(area), fixed = TRUE))
# set up centroids ####
# find a way to not hit memory limit for population weighting
if (gatvars$popwt) {
# may need to assign ID as row names
mb$label = "Loading population file. This step may be slow."
tcltk::setTkProgressBar(tmb, value = 0, title = mb$title,
label = mb$label)
temp <- weightGATmap(area = area, popvar = gatvars$popvar,
filevars = filevars, idvar = gatvars$myidvar)
mapvars$centroids <- temp$centroids
mapvars$pop <- temp$pop
# area@data$GATpop <- mapvars$centroids$GATpop
} else {
mapvars$centroids <- sp::coordinates(area)
colnames(mapvars$centroids) <- c("GATx", "GATy")
mapvars$pop <- NULL
}
# default to not lat/long if something goes wrong
if (is.na(mapvars$projection)) mapvars$projection <- FALSE
# add centroids to polygon data ####
aggvars <- list(IDlist = as.character(area@data[, gatvars$myidvar]),
allpolydata = data.frame(area@data, mapvars$centroids),
newregno = 1,
logmsg = "") # record merge warnings in the log)
# set up temporary variables ####
if (gatvars$aggregator2 == "NONE") gatvars$aggregator2 <- gatvars$aggregator1
# for some reason, numeric sometimes switched to character
aggvars$allpolydata[, gatvars$aggregator1] <-
as.numeric(as.character(aggvars$allpolydata[, gatvars$aggregator1]))
aggvars$allpolydata[, gatvars$aggregator2] <-
as.numeric(as.character(aggvars$allpolydata[, gatvars$aggregator2]))
temp <- list(alldata = aggvars$allpolydata[which(aggvars$allpolydata$GATflag == 0), ],
digits = nchar(nrow(aggvars$allpolydata)),
index = sapply(aggvars$allpolydata, is.integer),
rownames = area@data[, gatvars$myidvar])
# test if loop can be run ####
if (nrow(temp$alldata) > 0) {
# set up more temporary variables ####
temp$minpop1 = min(temp$alldata[, gatvars$aggregator1])
temp$minpop2 = min(temp$alldata[, gatvars$aggregator2])
myids <- as.character(unlist(data.frame(area@data[, gatvars$myidvar])))
myids <- myids[grepl("GATid", myids)]
myids <- gsub("GATid_", "",  myids)
if (length(myids) == 0) {
maxid <- 0
} else {
maxid <- max(as.numeric(myids))
temp$digits <- nchar(myids[1])
}
# set up town variables ####
# get list of neighbors using poly2nb method from spdep packagetow
townvars <- list(oldtownnb = spdep::poly2nb(area, queen = FALSE,
row.names = temp$rownames),
townnb = spdep::poly2nb(area, queen = FALSE,
row.names = temp$rownames))
# convert integers to double (change to convert when I read in file?)
# might be redundant now, but check later
aggvars$allpolydata[, temp$index] <-
sapply(aggvars$allpolydata[, temp$index], as.numeric)
# start while loop ####
while ((temp$minpop1 < gatvars$minvalue1) |
(temp$minpop2 < gatvars$minvalue2)){
# identify who is mergable ####
# remove flagged areas
temp$aggdata <-
aggvars$allpolydata[which(aggvars$allpolydata$GATflag == 0), ]
# isolate areas that are too small
temp$tobemerged <- temp$aggdata[which(
(temp$aggdata[, gatvars$aggregator1] < min1) |
(temp$aggdata[, gatvars$aggregator2] < min2) ), ]
# change the merge order high to low
if (temp$minpop1 < min1) {
temp$tobemerged <-
temp$tobemerged[order(-temp$tobemerged[, gatvars$aggregator1]), ]
} else {
temp$tobemerged <-
temp$tobemerged[order(-temp$tobemerged[, gatvars$aggregator2]), ]
}
# default merge option is the one selected
mergevars$mergeopt2 <- mergevars$mergeopt1
# incremental progress bar ####
mb$label <- paste0("Merge ", aggvars$newregno + maxid, ": ",
nrow(temp$tobemerged), " areas remaining.")
step <- nrow(area@data) - nrow(temp$tobemerged)
tcltk::setTkProgressBar(tmb, value = step, title = mb$title,
label = mb$label)
# identify the area to merge this loop ####
temp$first <- identifyGATfirstobs(tobemerged = temp$tobemerged,
aggvar = gatvars$aggregator1,
aggvar2 = gatvars$aggregator2,
minval = gatvars$minvalue1,
minval2 = gatvars$minvalue2)
# remove areas that are too large
temp$aggdata <- temp$aggdata[which(
(temp$aggdata[, gatvars$aggregator1] +
temp$first[, gatvars$aggregator1] < max1) |
(temp$aggdata[, gatvars$aggregator2] +
temp$first[, gatvars$aggregator2] < max2)), ]
# set up warnings ####
temp$logmsg <- paste0("Merge ", aggvars$newregno + maxid, " (",
temp$first[, gatvars$myidvar], "):")
temp$warnkey <- "n" # no warnings
warnings <- c(
ab = "No physically adjacent neighbors found within the same boundary.",
amb = "No physically adjacent neighbors below the minimum value found within the same boundary.",
mb = "Found areas in the same boundary below the minimum value, but they are not physically adjacent.",
b = "Found areas in the same boundary, but they are not physically adjacent.",
f = "No neighbors found. This area cannot be merged further.",
nb = "No neighbors found in boundary.",
am = "No physically adjacent neighbors found below the minimum aggregation value."
)
# find neighbors ####
# temporary flag: neighbors found?
temp$idfail <- TRUE
townvars$townnbid <- attr(townvars$townnb, "region.id")
if (temp$first[, gatvars$myidvar] %in% townvars$townnbid) {
townvars$townnbidloc <- which(townvars$townnbid ==
temp$first[, gatvars$myidvar])
townvars$neighbors <- townvars$townnb[[townvars$townnbidloc]]
townvars$neighborid <- townvars$townnbid[townvars$neighbors]
townvars$nbdata <-
temp$aggdata[which(temp$aggdata[, gatvars$myidvar] %in%
townvars$neighborid), ]
}
# get the data about these neighbors ####
# if boundary variable
if (gatvars$boundary != "NONE") {
temp$firstboundary <- as.character(temp$first[, gatvars$boundary])
# index of neighbors in same county
temp$inboundary <- townvars$nbdata[which(
townvars$nbdata[, gatvars$boundary] == temp$firstboundary), ]
# find neighbors in boundary, adjacent, below minimum value
if (minfirst) {
townvars$nbdata <-
temp$inboundary[which(temp$inboundary[, gatvars$aggregator1] < min1 |
temp$inboundary[, gatvars$aggregator2] < min2), ]
temp$inco_dex <- which(townvars$nbdata[, gatvars$boundary] ==
temp$firstboundary)
temp$inco_nbdata <- townvars$nbdata[temp$inco_dex, ]
if (nrow(temp$inco_nbdata) > 0) {
townvars$nbdata <- temp$inco_nbdata
temp$idfail <- FALSE
} else {
temp$warnkey <- "amb" # no adjacent below min within boundary
temp$idfail <- TRUE
}
}
# if no neighbors, find neighbors in boundary, adjacent
if (temp$idfail) {
townvars$nbdata <-
temp$inboundary[which(temp$inboundary[, gatvars$myidvar] %in%
townvars$neighborid), ]
# index of neighbors in same county
temp$inco_dex <- which(townvars$nbdata[, gatvars$boundary] ==
temp$firstboundary)
temp$inco_nbdata <- townvars$nbdata[temp$inco_dex, ]
if (nrow(temp$inco_nbdata) > 0) {
townvars$nbdata <- temp$inco_nbdata
temp$idfail <- FALSE # found neighbor
} else {
temp$warnkey <- "ab" # no adjacent within boundary
temp$idfail <- TRUE # still failed
}
}
# if no neighbors, find other area in boundary
if (!adjacent & temp$idfail) {
# below minimum preferred?
if (minfirst) {
temp$inco_nbdata <-
temp$tobemerged[which(temp$tobemerged[, gatvars$boundary] ==
temp$firstboundary &
temp$tobemerged[, gatvars$myidvar] !=
temp$first[, gatvars$myidvar]), ]
if(nrow(temp$inco_nbdata) > 0) {
townvars$nbdata <- temp$inco_nbdata
mergevars$mergeopt2 <- "closest"
temp$warnkey <- "mb"
temp$idfail <- FALSE
} else {
temp$idfail <- TRUE
}
}
# if still failing
if (temp$idfail) {
temp$inco_nbdata <-
temp$aggdata[which(temp$aggdata[, gatvars$boundary] ==
temp$firstboundary &
temp$aggdata[, gatvars$myidvar] !=
temp$first[, gatvars$myidvar]), ]
if(nrow(temp$inco_nbdata) > 0){
townvars$nbdata <- temp$inco_nbdata
mergevars$mergeopt2 <- "closest"
temp$warnkey <- "b"
temp$idfail <- FALSE
} else {
temp$idfail <- TRUE
}
}
}
if (temp$idfail) {
temp$warnkey <- "nb"
}
}
# if no boundary or none in boundary (and boundary not enforced)
if (minfirst & temp$idfail & !gatvars$rigidbound) {
# reset town list, just in case
townvars$nbdata <-
temp$tobemerged[which(temp$tobemerged[, gatvars$myidvar] %in%
townvars$neighborid), ]
if (nrow(townvars$nbdata) > 0) {
temp$idfail <- FALSE # found neighbor
} else {
temp$warnkey <- "am" # no adjacent below minimum
temp$idfail <- TRUE # still failed
}
}
# if no boundary or minimum enforcement (or none available)
if (!adjacent & temp$idfail & !gatvars$rigidbound) {
# reset town list, just in case
townvars$nbdata <-
townvars$nbdata[which(temp$aggdata[, gatvars$myidvar] %in%
townvars$neighborid), ]
if (nrow(townvars$nbdata) > 0) {
temp$idfail <- FALSE # found neighbor
} else {
if (temp$logmsg == "") {
temp$logmsg <- paste0(temp$logmsg, "Merge ", aggvars$newregno + maxid,
" (", temp$first[, gatvars$myidvar], "):")
}
temp$logmsg <- paste(temp$logmsg,
"No physically adjacent neighbors found.")
temp$idfail <- TRUE # still failed
}
if (temp$idfail) {
mergevars$mergeopt2 <- "closest"
townvars$townnbidloc <- which(townvars$townnbid ==
temp$first[, gatvars$myidvar])
townvars$neighbors <- townvars$townnb[[townvars$townnbidloc]]
townvars$neighborid <- townvars$townnbid[townvars$neighbors]
townvars$nbdata <-
temp$aggdata[which(temp$aggdata[, gatvars$myidvar] %in%
townvars$neighborid), ]
if (nrow(townvars$nbdata) > 0) {
temp$idfail <- FALSE # found neighbor
} else {
temp$idfail <- TRUE # still failed
}
}
}
# quit searching for neighbors ####
if(temp$idfail) {
# check for and remove flags and oversized at beginning of loop
aggvars$allpolydata$GATflag[aggvars$allpolydata[, gatvars$myidvar] ==
temp$first[, gatvars$myidvar]] <- 10
temp$warnkey <- "f"
} else {
# rank centroid distances ####
townvars$nborder <- rankGATdistance(area = area,
nbdata = townvars$nbdata,
first = temp$first,
gatvars = gatvars,
mergevars = mergevars)
# data which will be combined to form new region ####
townvars$newreg <- rbind(temp$first,
townvars$nbdata[townvars$nborder[1], ])
# add leading zeroes based on maximum number of areas
temp$zero <- paste(rep("0", temp$digits -
nchar(aggvars$newregno + maxid)),
collapse = "")
townvars$nrid <- paste0("GATid_", temp$zero,
as.character(aggvars$newregno + maxid))
temp$IDloc <- which(aggvars$IDlist %in% townvars$newreg[, gatvars$myidvar])
aggvars$IDlist[temp$IDloc] <- townvars$nrid
# calculate new region ####
townvars$newregdata <- createGATregion(mydata = aggvars$allpolydata,
newreg = townvars$newreg,
myidvar = gatvars$myidvar,
nrid = townvars$nrid,
area = area, pop = mapvars$pop,
IDlist = aggvars$IDlist,
pwrepeat = pwrepeat,
popwt = gatvars$popwt)
# add the new region to the list of data about the regions ####
aggvars$allpolydata <- rbind(aggvars$allpolydata, townvars$newregdata)
# need to remove the info about the old regions
aggvars$allpolydata <-
aggvars$allpolydata[which(!aggvars$allpolydata[, gatvars$myidvar] %in%
townvars$newreg[, gatvars$myidvar]), ]
# use spdep::aggregate.nb to create new object listing neighbors of aggregate
townvars$townnb <- spdep::aggregate.nb(townvars$oldtownnb, aggvars$IDlist)
aggvars$newregno <- aggvars$newregno + 1
}
# find the minimum population ####
temp$minpop1 <- min(aggvars$allpolydata[which(aggvars$allpolydata$GATflag == 0),
gatvars$aggregator1])
temp$minpop2 <- min(aggvars$allpolydata[which(aggvars$allpolydata$GATflag == 0),
gatvars$aggregator2])
if (temp$warnkey != "n") {
aggvars$logmsg <- paste(aggvars$logmsg, temp$logmsg,
warnings[temp$warnkey], "\n")
}
# 'garbage collection': free up memory ####
gc(verbose = FALSE)
}
} else {
if (gatvars$aggregator1 == gatvars$aggregator2) {
vars <- gatvars$aggregator1
} else {
vars <- paste(gatvars$aggregator1, "and", gatvars$aggregator2)
}
msg <- paste("All areas have values of", vars,
"over your selected minimum value(s). No areas were merged.")
tcltk::tkmessageBox(title = "Merge failed", message = msg,
type = "yesno", icon = "info")
}
# if function is isolated, close progress bar that monitors the aggregation
close(tmb)
return(aggvars)
}
path <- "P:/Sections/EHS/Abigail/SubcountyData/Rcode/GATtest/testdata/tract_mcd/"
set <- "gat_step2_newmcdsettings.Rdata"
runGATprogram_testmin(settings = paste0(path, "/", set), minfirst = TRUE)
path <- "P:/Sections/EHS/Arjita/EPHT/Sub-County/Creating new Agg Areas/with GAT147"
set <- "PWC_Gat_step2settings.Rdata"
runGATprogram_testmin(settings = paste0(path, "/", set), minfirst = TRUE)
devtools::check()
browseVignettes("gatpkg")
browseVignettes(gatpkg)
gatpkg::inputGATmergepop(mapdata = gatpkg::hftown@data, aggvar = "TOTAL_POP", aggvar2 = "NONE")
# code to generate window for inputGATmergepop.png
gatpkg::inputGATmerge(mapdata = gatpkg::hftown@data, aggvar = "TOTAL_POP", aggvar2 = "NONE")
# code to generate window for inputGATrate.png
gatpkg::inputGATrate(mapdata = gatpkg::hftown@data, limitdenom = FALSE)
# code to generate window for saveGATkml.png
gatpkg::saveGATkml()
devtools::build()
remove.packages("gatpkg", lib="~/R/win-library/3.6")
install.packages("P:/Sections/EHS/Abigail/SubcountyData/Rcode/gatpkg_1.49.tar.gz", repos = NULL, type = "source")
browseVignettes("gatpkg")
gatpkg::runGATprogram()
gatpkg::runGATprogram(minfirst = TRUE, settings = "P:/Sections/EHS/Abigail/SubcountyData/Rcode/GATtest/testdata/abby/hh_nominfirstsettings.Rdata")
library(gatpkg)
path <- "P:/Sections/EHS/Abigail/SubcountyData/Rcode/GATtest/testdata/abby"
set1 <- "hh_minfirstsettings.Rdata"
set2 <- "hh_nominfirstsettings.Rdata"
runGATprogram(settings = paste0(path, "/", set1), minfirst = TRUE)
runGATprogram(settings = paste0(path, "/", set2), minfirst = FALSE)
path <- "P:/Sections/EHS/Abigail/SubcountyData/Rcode/GATtest/testdata/abby"
set1 <- "hh_minfirstsettings.Rdata"
set2 <- "hh_nominfirstsettings.Rdata"
runGATprogram(settings = paste0(path, "/", set1), minfirst = TRUE)
runGATprogram(settings = paste0(path, "/", set2), minfirst = FALSE)
devtools::check()
devtools::build()
??BWidget
vignette("gat_tech_notes", package = "gatpkg")
vignette("tech_notes", package = "gatpkg")
browseVignettes("gatpkg")
vignette("gat_tutorial", package = "gatpkg")
remove.packages("gatpkg", lib="~/R/win-library/3.6")
install.packages("P:/Sections/EHS/Abigail/SubcountyData/Rcode/gatpkg_1.50.tar.gz", repos = NULL, type = "source")
browseVignettes("gatpkg")
vignette("gat_tech_notes", package = "gatpkg")
