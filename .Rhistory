boundary = "county",
rigidbound = FALSE,
popvar = "total_pop",
savekml = TRUE,
numrow = 15
)
mergevars <-
list(
mergeopt1 = "similar", # can be similar, closest, or least
similar1 = "ratio1",
similar2 = "ratio2",
centroid = "geographic"
)
ratevars <-
list(
ratename = "my_rate",
numerator = "case",
denominator = "pop",
multiplier = 100000
)
exclist <-
list(
var1 = "exclusion1",
var2 = "exclusion2",
var3 = "NONE", # flag to denote no third variable
math1 = "greater than",
math2 = "less than",
math3 = "equals",
val1 = 10000,
val2 = 50,
val3 = 0,
flagsum = 5
)
filevars <-
list(
filein = "hftown",
popfile = "hfblock",
fileout = "my_savefile",
userin = "C:/users/default/shapefiles/hftown",
userout = "C:/users/default/shapefiles/my_saves/my_savefile"
)
confirmGATbystep(
gatvars = gatvars,
ratevars = ratevars,
mergevars = mergevars,
exclist = exclist,
filevars = filevars,
step = 10
)
runGATprogram()
devtools::check()
devtools::build()
devtools::install()
library(gatpkg)
runGATprogram()
runGATprogram()
runGATprogram(settings = "P:/Sections/EHS/Abigail/SubcountyData/Rcode/GATtest/testresults/ ajs_demo_20191212settings.Rdata")
runGATprogram(settings = "P:/Sections/EHS/Abigail/SubcountyData/Rcode/GATtest/testresults/ajs_demo_20191212settings.Rdata")
runGATprogram(settings = " P:/Common/BEOE Projects/EPHTintern/Marine/GATtest/testresults/ajs_demo_20191212settings.Rdata")
runGATprogram(settings = "P:/Common/BEOE Projects/EPHTintern/Marine/GATtest/testresults/ajs_demo_20191212settings.Rdata")
runGATprogram(limitdenom = TRUE)
runGATprogram(limitdenom = TRUE)
runGATprogram(settings = "P:/Common/BEOE Projects/EPHTintern/Marine/GATtest/testresults/ajs_demo_20191212settings.Rdata")
browseVignettes("gatpkg")
?gatpkg::locateGATshapefile
filepath <- paste0(tools::getVignetteInfo("gatpkg", all = TRUE)[1, "Dir"], "/extdata/")
filepath
gatpkg::runGATprogram()
?gatpkg::inputGATrate
# define rate settings
inputGATrate(
mapdata = hftown@data,
help = "hlp",
limitdenom = FALSE
)
library(gatpkg)
# define rate settings
inputGATrate(
mapdata = hftown@data,
help = "hlp",
limitdenom = FALSE
)
# define rate settings
inputGATrate(
mapdata = hftown@data,
help = "hlp",
limitdenom = FALSE
)
# define rate settings
x <- inputGATrate(
mapdata = hftown@data,
help = "hlp",
limitdenom = FALSE
)
exists(x$g)
exists("x$g")
exists("x$colorname")
exists(x["colorname"])
exists("colorname", x)
exists("g", x)
?choose.files
?grepl
devtools::check()
devtools::build()
devtools::install()
?gatpkg
remove.packages("gatpkg", lib="~/R/win-library/3.6")
devtools::install()
?gatpkg
install.packages(c("aqp", "broom", "deldir", "dplyr", "jsonlite", "lwgeom", "magick", "raster", "RgoogleMaps", "rlang", "rmapshaper", "sf", "tidyselect", "tokenbrowser", "yaml"))
plotGATmaps <- function(area, var, clr = "Blues", title.main = "", class = NULL,
after = FALSE, title.sub = NULL, breaks = 5,
colcode = NULL, mapstats = FALSE, ratemap = FALSE) {
# set map size
dev.new(noRStudioGD = TRUE, res = 1200, width = 20, height = 14)
# enable display list
dev.control('enable')
# plot shapefile
graphics::par(mar=c(2.5,0,2,0), mgp = c(0, 0, 0), xpd = TRUE)
# margins: bottom, left, top, right
# axes: label, padding, tick (?)
# xpd: draw outside margins?
sp::plot(area, lwd=.5)
title(main = title.main, sub = title.sub, cex.main = 2)
if (is.null(colcode)) {
if (!ratemap) {
if (is.null(class)) {
plotvar <- area@data[, var]
plotvargood <- plotvar[which(is.finite(plotvar))]
if (length(table(plotvargood)) < breaks) {
breaks = length(table(plotvargood))
myclass <- classInt::classIntervals(area@data[, var], breaks,
style = "fixed",
fixedBreaks = names(table(plotvargood)),
warnSmallN = FALSE)
} else {
myclass <- classInt::classIntervals(plotvargood, breaks,
style = "quantile",
warnSmallN = FALSE)
}
} else if (after == TRUE) {
maxpop <- max(area@data[, var])
mybreaks <- c(class$brks, maxpop)
# set upper limits for maps accordingly, so all data is within some range
myclass <- classInt::classIntervals(area@data[, var], breaks,
style = "fixed",
fixedBreaks = mybreaks,
warnSmallN = FALSE)
} else {
myclass <- class
}
# assigns a color to each region
plotclr <- RColorBrewer::brewer.pal(breaks, clr)
colcode <- classInt::findColours(myclass, plotclr)
} else if (ratemap) {
plotvar <- area@data[, var]
plotgood <- plotvar[which(is.finite(plotvar))] # removes missings
missingtag <- 10*max(plotgood)
area@data$rateplot <- ifelse(!is.finite(plotvar) | is.na(plotvar),
missingtag, plotvar)
myclass <- classInt::classIntervals(plotgood, breaks,
style = "quantile")
mybreaks <- c(floor(myclass$brks[1]*100)/100,
round(myclass$brks[2:breaks], digits = 2),
ceiling(myclass$brks[breaks+1]*100)/100)
plotclr <- RColorBrewer::brewer.pal(breaks, clr)
if (sum(!is.finite(plotvar) | is.na(plotvar)) > 0) {
mybreaks <- c(mybreaks, ceiling(missingtag))
plotclr <- c(plotclr, "#C8C8C8")
}
myclass <- classInt::classIntervals(area@data$rateplot, style = "fixed",
fixedBreaks = mybreaks)
colcode <- classInt::findColours(myclass, plotclr)
if (sum(!is.finite(plotvar) | is.na(plotvar)) > 0) {
names(attr(colcode, "table"))[breaks+1] <- "Rate cannot be calculated"
names(attr(colcode, "table"))[breaks] <-
gsub(",.+)", paste0(", ", ceiling(missingtag*10)/100, "]"),
names(attr(colcode, "table"))[breaks])
}
}
}
sp::plot(area, col = colcode, add = TRUE, lwd=.5)
labels = names(attr(colcode, "table"))
fill = attr(colcode, "palette")
border = rep("black", length(fill))
# highlight flagged areas if relevant
myflags <- subset(area, area@data$GATflag %in% 1:3)
if (nrow(myflags@data) > 0) {
sp::plot(myflags, border = "LightSteelBlue", add = TRUE, lwd = 3)
labels = c(labels, "Excluded by user")
fill = c(fill, "white")
border = c(border, "LightSteelBlue")
}
myflags <- subset(area, area@data$GATflag == 10)
if (nrow(myflags@data) > 0) {
sp::plot(myflags, border = "cyan", add = TRUE, lwd = 3)
labels = c(labels, "Below minimum aggregation value")
fill = c(fill, "white")
border = c(border, "cyan")
}
myflags <- subset(area, area@data$GATflag == 5)
if (nrow(myflags@data) > 0) {
sp::plot(myflags, border = "magenta", add = TRUE, lwd = 3)
labels = c(labels, "Above maximum aggregation value")
fill = c(fill, "white")
border = c(border, "magenta")
}
legend("topleft", legend = labels, fill = fill, border = border, cex = 1,
bty = "n", inset = 0, y.intersp = 1.25)
# calculate summary statistics if mapstats = TRUE
if (mapstats) {
statsvar <- area@data[, var]
statsgood <- statsvar[which(is.finite(statsvar))]
if (ratemap) {
min <- round(min(statsgood), digits = 2)
max <- round(max(statsgood), digits = 2)
med <- round(stats::median(statsgood), digits = 2)
} else {
min <- min(statsgood)
max <- max(statsgood)
med <- round(stats::median(statsgood))
}
numformat <- function(num) {
format(as.numeric(gsub(",", "", num)), big.mark=",", scientific=FALSE)
}
stats <- paste("Summary stats for \n", var, ":     \n",
"Minimum:", numformat(min), "\n",
"Median:", numformat(med), "\n",
"Maximum:", numformat(max), "\n")
# get latitude/longitude limits from shapefile
extent <- sp::bbox(area)
if (extent["x", "max"] - extent["x", "min"] < (extent["y", "max"] - extent["y", "min"])) {
xbuffer <- extent["x", "max"] + (extent["x", "max"] - extent["x", "min"]) / 2
} else if (extent["x", "max"] - extent["x", "min"] <
(extent["y", "max"] - extent["y", "min"]) * 3/2) {
xbuffer <- extent["x", "max"] + (extent["x", "max"] - extent["x", "min"]) / 4
} else {
xbuffer <- extent["x", "max"]
}
graphics::text(xbuffer, extent["y", "max"], labels = stats, adj = c(1, 1))
# play with "pos" a bit; there has to be a more efficient method
}
# only include this last part if prettymapr is installed
if (requireNamespace("prettymapr", quietly = TRUE)) {
suppressMessages(
prettymapr::addnortharrow(pos = "bottomleft", padin = c(0.2, 0.05),
scale = .5, lwd = 1, border = "black",
cols = c("white", "black"), text.col = "black")
)
suppressMessages(
prettymapr::addscalebar(plotunit = "mi", plotepsg = 4269, widthhint = 0.25,
unitcategory = "imperial", htin = 0.1, lwd = 1,
padin = c(0.7, 0.05), style = "ticks",
linecol = "black", tick.cex = 0.7,
labelpadin = 0.08, label.cex = 0.8,
label.col = "black", pos = "bottomleft")
)
}
map <- recordPlot()
graphics::par(mar=c(5,4,4,2)+.1, mgp = c(3, 1, 0)) # default bottom, left, top, right
# dev.off()
return(map)
}
library(gatpkg)
?plotGATmaps
## plot population
# create a randomized flag variable (will not match label)
hftown@data$GATflag <-
sample(
c(0, 10), nrow(hftown@data),
replace = TRUE,
prob = c(.9, .1)
)
# plot the variable
plotGATmaps(
area = hftown,
var = "TOTAL_POP",
clr = "YlGn",
title.main = "Population",
breaks = 3,
mapstats = TRUE
)
## plot a rate
# create a randomized flag variable (will not match labels)
# 0 = no flag, 1-3 = excluded by user, 10 = below minimum aggregation value
hftown@data$GATflag <-
sample(
c(0, 1, 10), nrow(hftown@data),
replace = TRUE,
prob = c(.8, .1, .1)
)
# create a rate
hftown@data$pct_white <- 100 * hftown@data$W_TOT / hftown@data$TOTAL_POP
# add some random missings to illustrate uncalculated rates
hftown@data$pct_white[sample(length(hftown@data), 2)] <- NA
# plot the rate
plotGATmaps(
area = hftown,
var = "pct_white",
clr = "YlGn",
title.main = "Percent of population that is white",
breaks = 3,
mapstats = TRUE,
ratemap = TRUE
)
plotGATmaps <- function(area, var, clr = "Blues", title.main = "", class = NULL,
after = FALSE, title.sub = NULL, breaks = 5,
colcode = NULL, mapstats = FALSE, ratemap = FALSE) {
# set map size
dev.new(noRStudioGD = TRUE, res = 1200, width = 20, height = 14)
# enable display list
dev.control('enable')
# plot shapefile
graphics::par(mar=c(2.5,0,2,0), mgp = c(0, 0, 0), xpd = TRUE)
# margins: bottom, left, top, right
# axes: label, padding, tick (?)
# xpd: draw outside margins?
sp::plot(area, lwd=.5)
title(main = title.main, sub = title.sub, cex.main = 2)
if (is.null(colcode)) {
if (!ratemap) {
if (is.null(class)) {
plotvar <- area@data[, var]
plotvargood <- plotvar[which(is.finite(plotvar))]
if (length(table(plotvargood)) < breaks) {
breaks = length(table(plotvargood))
myclass <- classInt::classIntervals(area@data[, var], breaks,
style = "fixed",
fixedBreaks = names(table(plotvargood)),
warnSmallN = FALSE)
} else {
myclass <- classInt::classIntervals(plotvargood, breaks,
style = "quantile",
warnSmallN = FALSE)
}
} else if (after == TRUE) {
maxpop <- max(area@data[, var])
mybreaks <- c(class$brks, maxpop)
# set upper limits for maps accordingly, so all data is within some range
myclass <- classInt::classIntervals(area@data[, var], breaks,
style = "fixed",
fixedBreaks = mybreaks,
warnSmallN = FALSE)
} else {
myclass <- class
}
# assigns a color to each region
plotclr <- RColorBrewer::brewer.pal(breaks, clr)
colcode <- classInt::findColours(myclass, plotclr)
} else if (ratemap) {
plotvar <- area@data[, var]
plotgood <- plotvar[which(is.finite(plotvar))] # removes missings
missingtag <- 10*max(plotgood)
area@data$rateplot <- ifelse(!is.finite(plotvar) | is.na(plotvar),
missingtag, plotvar)
myclass <- classInt::classIntervals(plotgood, breaks,
style = "quantile")
mybreaks <- c(floor(myclass$brks[1]*100)/100,
round(myclass$brks[2:breaks], digits = 2),
ceiling(myclass$brks[breaks+1]*100)/100)
plotclr <- RColorBrewer::brewer.pal(breaks, clr)
if (sum(!is.finite(plotvar) | is.na(plotvar)) > 0) {
mybreaks <- c(mybreaks, ceiling(missingtag))
plotclr <- c(plotclr, "Lavender")
}
myclass <- classInt::classIntervals(area@data$rateplot, style = "fixed",
fixedBreaks = mybreaks)
colcode <- classInt::findColours(myclass, plotclr)
if (sum(!is.finite(plotvar) | is.na(plotvar)) > 0) {
names(attr(colcode, "table"))[breaks+1] <- "Rate cannot be calculated"
names(attr(colcode, "table"))[breaks] <-
gsub(",.+)", paste0(", ", ceiling(missingtag*10)/100, "]"),
names(attr(colcode, "table"))[breaks])
}
}
}
sp::plot(area, col = colcode, add = TRUE, lwd=.5)
labels = names(attr(colcode, "table"))
fill = attr(colcode, "palette")
border = rep("black", length(fill))
# highlight flagged areas if relevant
myflags <- subset(area, area@data$GATflag %in% 1:3)
if (nrow(myflags@data) > 0) {
sp::plot(myflags, border = "CornflowerBlue", add = TRUE, lwd = 3)
labels = c(labels, "Excluded by user")
fill = c(fill, "white")
border = c(border, "CornflowerBlue")
}
myflags <- subset(area, area@data$GATflag == 10)
if (nrow(myflags@data) > 0) {
sp::plot(myflags, border = "cyan", add = TRUE, lwd = 3)
labels = c(labels, "Below minimum aggregation value")
fill = c(fill, "white")
border = c(border, "cyan")
}
myflags <- subset(area, area@data$GATflag == 5)
if (nrow(myflags@data) > 0) {
sp::plot(myflags, border = "magenta", add = TRUE, lwd = 3)
labels = c(labels, "Above maximum aggregation value")
fill = c(fill, "white")
border = c(border, "magenta")
}
legend("topleft", legend = labels, fill = fill, border = border, cex = 1,
bty = "n", inset = 0, y.intersp = 1.25)
# calculate summary statistics if mapstats = TRUE
if (mapstats) {
statsvar <- area@data[, var]
statsgood <- statsvar[which(is.finite(statsvar))]
if (ratemap) {
min <- round(min(statsgood), digits = 2)
max <- round(max(statsgood), digits = 2)
med <- round(stats::median(statsgood), digits = 2)
} else {
min <- min(statsgood)
max <- max(statsgood)
med <- round(stats::median(statsgood))
}
numformat <- function(num) {
format(as.numeric(gsub(",", "", num)), big.mark=",", scientific=FALSE)
}
stats <- paste("Summary stats for \n", var, ":     \n",
"Minimum:", numformat(min), "\n",
"Median:", numformat(med), "\n",
"Maximum:", numformat(max), "\n")
# get latitude/longitude limits from shapefile
extent <- sp::bbox(area)
if (extent["x", "max"] - extent["x", "min"] < (extent["y", "max"] - extent["y", "min"])) {
xbuffer <- extent["x", "max"] + (extent["x", "max"] - extent["x", "min"]) / 2
} else if (extent["x", "max"] - extent["x", "min"] <
(extent["y", "max"] - extent["y", "min"]) * 3/2) {
xbuffer <- extent["x", "max"] + (extent["x", "max"] - extent["x", "min"]) / 4
} else {
xbuffer <- extent["x", "max"]
}
graphics::text(xbuffer, extent["y", "max"], labels = stats, adj = c(1, 1))
# play with "pos" a bit; there has to be a more efficient method
}
# only include this last part if prettymapr is installed
if (requireNamespace("prettymapr", quietly = TRUE)) {
suppressMessages(
prettymapr::addnortharrow(pos = "bottomleft", padin = c(0.2, 0.05),
scale = .5, lwd = 1, border = "black",
cols = c("white", "black"), text.col = "black")
)
suppressMessages(
prettymapr::addscalebar(plotunit = "mi", plotepsg = 4269, widthhint = 0.25,
unitcategory = "imperial", htin = 0.1, lwd = 1,
padin = c(0.7, 0.05), style = "ticks",
linecol = "black", tick.cex = 0.7,
labelpadin = 0.08, label.cex = 0.8,
label.col = "black", pos = "bottomleft")
)
}
map <- recordPlot()
graphics::par(mar=c(5,4,4,2)+.1, mgp = c(3, 1, 0)) # default bottom, left, top, right
# dev.off()
return(map)
}
## plot population
# create a randomized flag variable (will not match label)
hftown@data$GATflag <-
sample(
c(0, 10), nrow(hftown@data),
replace = TRUE,
prob = c(.9, .1)
)
# plot the variable
plotGATmaps(
area = hftown,
var = "TOTAL_POP",
clr = "YlGn",
title.main = "Population",
breaks = 3,
mapstats = TRUE
)
## plot a rate
# create a randomized flag variable (will not match labels)
# 0 = no flag, 1-3 = excluded by user, 10 = below minimum aggregation value
hftown@data$GATflag <-
sample(
c(0, 1, 10), nrow(hftown@data),
replace = TRUE,
prob = c(.8, .1, .1)
)
# create a rate
hftown@data$pct_white <- 100 * hftown@data$W_TOT / hftown@data$TOTAL_POP
# add some random missings to illustrate uncalculated rates
hftown@data$pct_white[sample(length(hftown@data), 2)] <- NA
# plot the rate
plotGATmaps(
area = hftown,
var = "pct_white",
clr = "YlGn",
title.main = "Percent of population that is white",
breaks = 3,
mapstats = TRUE,
ratemap = TRUE
)
?inputGATrate
inputGATrate(
mapdata = hftown@data,
help = "hlp",
limitdenom = FALSE
)
detach("package:gatpkg", unload = TRUE)
remove.packages("gatpkg", lib="~/R/win-library/3.6")
devtools::check()
devtools::build()
devtools::install()
library(gatpkg)
runGATprogram()
runGATprogram()
