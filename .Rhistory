}
# get the data about these neighbors ####
# if boundary variable
if (gatvars$boundary != "NONE") {
temp$firstboundary <- as.character(temp$first[, gatvars$boundary])
# index of neighbors in same county
temp$inboundary <- townvars$nbdata[which(
townvars$nbdata[, gatvars$boundary] == temp$firstboundary), ]
# find neighbors in boundary, adjacent, below minimum value
if (minfirst) {
townvars$nbdata <-
temp$inboundary[which(temp$inboundary[, gatvars$aggregator1] < min1 |
temp$inboundary[, gatvars$aggregator2] < min2), ]
temp$inco_dex <- which(townvars$nbdata[, gatvars$boundary] ==
temp$firstboundary)
temp$inco_nbdata <- townvars$nbdata[temp$inco_dex, ]
if (nrow(temp$inco_nbdata) > 0) {
townvars$nbdata <- temp$inco_nbdata
temp$idfail <- FALSE
} else {
temp$warnkey <- "amb" # no adjacent below min within boundary
temp$idfail <- TRUE
}
}
# if no neighbors, find neighbors in boundary, adjacent
if (temp$idfail) {
townvars$nbdata <-
temp$inboundary[which(temp$inboundary[, gatvars$myidvar] %in%
townvars$neighborid), ]
# index of neighbors in same county
temp$inco_dex <- which(townvars$nbdata[, gatvars$boundary] ==
temp$firstboundary)
temp$inco_nbdata <- townvars$nbdata[temp$inco_dex, ]
if (nrow(temp$inco_nbdata) > 0) {
townvars$nbdata <- temp$inco_nbdata
temp$idfail <- FALSE # found neighbor
} else {
temp$warnkey <- "ab" # no adjacent within boundary
temp$idfail <- TRUE # still failed
}
}
# if no neighbors, find other area in boundary
if (!adjacent & temp$idfail) {
# below minimum preferred?
if (minfirst) {
temp$inco_nbdata <-
temp$tobemerged[which(temp$tobemerged[, gatvars$boundary] ==
temp$firstboundary &
temp$tobemerged[, gatvars$myidvar] !=
temp$first[, gatvars$myidvar]), ]
if(nrow(temp$inco_nbdata) > 0) {
townvars$nbdata <- temp$inco_nbdata
mergevars$mergeopt2 <- "closest"
temp$warnkey <- "mb"
temp$idfail <- FALSE
} else {
temp$idfail <- TRUE
}
}
# if still failing
if (temp$idfail) {
temp$inco_nbdata <-
temp$aggdata[which(temp$aggdata[, gatvars$boundary] ==
temp$firstboundary &
temp$aggdata[, gatvars$myidvar] !=
temp$first[, gatvars$myidvar]), ]
if(nrow(temp$inco_nbdata) > 0){
townvars$nbdata <- temp$inco_nbdata
mergevars$mergeopt2 <- "closest"
temp$warnkey <- "b"
temp$idfail <- FALSE
} else {
temp$idfail <- TRUE
}
}
}
if (temp$idfail) {
temp$warnkey <- "nb"
}
}
# if no boundary or none in boundary (and boundary not enforced)
if (minfirst & temp$idfail & !gatvars$rigidbound) {
# reset town list, just in case
townvars$nbdata <-
temp$tobemerged[which(temp$tobemerged[, gatvars$myidvar] %in%
townvars$neighborid), ]
if (nrow(townvars$nbdata) > 0) {
temp$idfail <- FALSE # found neighbor
} else {
temp$warnkey <- "am" # no adjacent below minimum
temp$idfail <- TRUE # still failed
}
}
# if no boundary or minimum enforcement (or none available)
if (!adjacent & temp$idfail & !gatvars$rigidbound) {
# reset town list, just in case
townvars$nbdata <-
townvars$nbdata[which(temp$aggdata[, gatvars$myidvar] %in%
townvars$neighborid), ]
if (nrow(townvars$nbdata) > 0) {
temp$idfail <- FALSE # found neighbor
} else {
if (temp$logmsg == "") {
temp$logmsg <- paste0(temp$logmsg, "Merge ", aggvars$newregno + maxid,
" (", temp$first[, gatvars$myidvar], "):")
}
temp$logmsg <- paste(temp$logmsg,
"No physically adjacent neighbors found.")
temp$idfail <- TRUE # still failed
}
if (temp$idfail) {
mergevars$mergeopt2 <- "closest"
townvars$townnbidloc <- which(townvars$townnbid ==
temp$first[, gatvars$myidvar])
townvars$neighbors <- townvars$townnb[[townvars$townnbidloc]]
townvars$neighborid <- townvars$townnbid[townvars$neighbors]
townvars$nbdata <-
temp$aggdata[which(temp$aggdata[, gatvars$myidvar] %in%
townvars$neighborid), ]
if (nrow(townvars$nbdata) > 0) {
temp$idfail <- FALSE # found neighbor
} else {
temp$idfail <- TRUE # still failed
}
}
}
# quit searching for neighbors ####
if(temp$idfail) {
# check for and remove flags and oversized at beginning of loop
aggvars$allpolydata$GATflag[aggvars$allpolydata[, gatvars$myidvar] ==
temp$first[, gatvars$myidvar]] <- 10
temp$warnkey <- "f"
} else {
# rank centroid distances ####
townvars$nborder <- rankGATdistance(area = area,
nbdata = townvars$nbdata,
first = temp$first,
gatvars = gatvars,
mergevars = mergevars)
# data which will be combined to form new region ####
townvars$newreg <- rbind(temp$first,
townvars$nbdata[townvars$nborder[1], ])
# add leading zeroes based on maximum number of areas
temp$zero <- paste(rep("0", temp$digits -
nchar(aggvars$newregno + maxid)),
collapse = "")
townvars$nrid <- paste0("GATid_", temp$zero,
as.character(aggvars$newregno + maxid))
temp$IDloc <- which(aggvars$IDlist %in% townvars$newreg[, gatvars$myidvar])
aggvars$IDlist[temp$IDloc] <- townvars$nrid
# calculate new region ####
townvars$newregdata <- createGATregion(mydata = aggvars$allpolydata,
newreg = townvars$newreg,
myidvar = gatvars$myidvar,
nrid = townvars$nrid,
area = area, pop = mapvars$pop,
IDlist = aggvars$IDlist,
pwrepeat = pwrepeat,
popwt = gatvars$popwt)
# add the new region to the list of data about the regions ####
aggvars$allpolydata <- rbind(aggvars$allpolydata, townvars$newregdata)
# need to remove the info about the old regions
aggvars$allpolydata <-
aggvars$allpolydata[which(!aggvars$allpolydata[, gatvars$myidvar] %in%
townvars$newreg[, gatvars$myidvar]), ]
# use spdep::aggregate.nb to create new object listing neighbors of aggregate
townvars$townnb <- spdep::aggregate.nb(townvars$oldtownnb, aggvars$IDlist)
aggvars$newregno <- aggvars$newregno + 1
}
# find the minimum population ####
temp$minpop1 <- min(aggvars$allpolydata[which(aggvars$allpolydata$GATflag == 0),
gatvars$aggregator1])
temp$minpop2 <- min(aggvars$allpolydata[which(aggvars$allpolydata$GATflag == 0),
gatvars$aggregator2])
if (temp$warnkey != "n") {
aggvars$logmsg <- paste(aggvars$logmsg, temp$logmsg,
warnings[temp$warnkey], "\n")
}
# 'garbage collection': free up memory ####
gc(verbose = FALSE)
}
} else {
if (gatvars$aggregator1 == gatvars$aggregator2) {
vars <- gatvars$aggregator1
} else {
vars <- paste(gatvars$aggregator1, "and", gatvars$aggregator2)
}
msg <- paste("All areas have values of", vars,
"over your selected minimum value(s). No areas were merged.")
tcltk::tkmessageBox(title = "Merge failed", message = msg,
type = "yesno", icon = "info")
}
# if function is isolated, close progress bar that monitors the aggregation
close(tmb)
return(aggvars)
}
path <- "P:/Sections/EHS/Abigail/SubcountyData/Rcode/GATtest/testdata/tract_mcd/"
set <- "gat_step2_newmcdsettings.Rdata"
runGATprogram_testmin(settings = paste0(path, "/", set), minfirst = TRUE)
path <- "P:/Sections/EHS/Arjita/EPHT/Sub-County/Creating new Agg Areas/with GAT147"
set <- "PWC_Gat_step2settings.Rdata"
runGATprogram_testmin(settings = paste0(path, "/", set), minfirst = TRUE)
devtools::check()
browseVignettes("gatpkg")
browseVignettes(gatpkg)
gatpkg::inputGATmergepop(mapdata = gatpkg::hftown@data, aggvar = "TOTAL_POP", aggvar2 = "NONE")
# code to generate window for inputGATmergepop.png
gatpkg::inputGATmerge(mapdata = gatpkg::hftown@data, aggvar = "TOTAL_POP", aggvar2 = "NONE")
# code to generate window for inputGATrate.png
gatpkg::inputGATrate(mapdata = gatpkg::hftown@data, limitdenom = FALSE)
# code to generate window for saveGATkml.png
gatpkg::saveGATkml()
devtools::build()
remove.packages("gatpkg", lib="~/R/win-library/3.6")
install.packages("P:/Sections/EHS/Abigail/SubcountyData/Rcode/gatpkg_1.49.tar.gz", repos = NULL, type = "source")
browseVignettes("gatpkg")
gatpkg::runGATprogram()
gatpkg::runGATprogram(minfirst = TRUE, settings = "P:/Sections/EHS/Abigail/SubcountyData/Rcode/GATtest/testdata/abby/hh_nominfirstsettings.Rdata")
library(gatpkg)
path <- "P:/Sections/EHS/Abigail/SubcountyData/Rcode/GATtest/testdata/abby"
set1 <- "hh_minfirstsettings.Rdata"
set2 <- "hh_nominfirstsettings.Rdata"
runGATprogram(settings = paste0(path, "/", set1), minfirst = TRUE)
runGATprogram(settings = paste0(path, "/", set2), minfirst = FALSE)
path <- "P:/Sections/EHS/Abigail/SubcountyData/Rcode/GATtest/testdata/abby"
set1 <- "hh_minfirstsettings.Rdata"
set2 <- "hh_nominfirstsettings.Rdata"
runGATprogram(settings = paste0(path, "/", set1), minfirst = TRUE)
runGATprogram(settings = paste0(path, "/", set2), minfirst = FALSE)
devtools::check()
devtools::build()
??BWidget
vignette("gat_tech_notes", package = "gatpkg")
vignette("tech_notes", package = "gatpkg")
browseVignettes("gatpkg")
vignette("gat_tutorial", package = "gatpkg")
remove.packages("gatpkg", lib="~/R/win-library/3.6")
install.packages("P:/Sections/EHS/Abigail/SubcountyData/Rcode/gatpkg_1.50.tar.gz", repos = NULL, type = "source")
browseVignettes("gatpkg")
vignette("gat_tech_notes", package = "gatpkg")
browseVignettes("gatpkg")
knitr::include_graphics("images/locateGATshapefile.png")
knitr::include_graphics("images/saveGATkml.png")
# fix this image and pre-select options
browseVignettes("gatpkg")
library(gatpkg)
?confirmGATbystep
gatvars <-
list(
aggregator1 = "agg1",
aggregator2 = "agg2",
myidvar = "tract",
minvalue1 = 5000,
minvalue2 = 10000,
maxvalue1 = 10000,
maxvalue2 = 15000,
boundary = "county",
rigidbound = FALSE,
popvar = "total_pop",
savekml = TRUE,
numrow = 15,
exclmaxval = 2
)
mergevars <-
list(
mergeopt1 = "similar", # can be similar, closest, or least
similar1 = "ratio1",
similar2 = "ratio2",
centroid = "geographic"
)
ratevars <-
list(
ratename = "my_rate",
numerator = "case",
denominator = "pop",
multiplier = 100000,
colorname = "Blue-Green"
)
exclist <-
list(
var1 = "exclusion1",
var2 = "exclusion2",
var3 = "NONE", # flag to denote no third variable
math1 = "greater than",
math2 = "less than",
math3 = "equals",
val1 = 10000,
val2 = 50,
val3 = 0,
flagsum = 5
)
filevars <-
list(
filein = "hftown",
popfile = "hfblock",
fileout = "my_savefile",
userin = "C:/users/default/shapefiles/hftown",
userout = "C:/users/default/shapefiles/my_saves/my_savefile"
)
confirmGATbystep(
gatvars = gatvars,
ratevars = ratevars,
mergevars = mergevars,
exclist = exclist,
filevars = filevars,
step = 10
)
# code to generate window for locateGATshapefile.png
gatvars <- list(aggregator1 = "TOTAL_POP", aggregator2 = "TOTAL_POP",
myidvar = "ID", minvalue1 = 5000, minvalue2 = 5000,
boundary = "COUNTY", rigidbound = TRUE, popvar = "Pop_tot",
savekml = FALSE)
mergevars <- list(mergeopt1 = "closest", similar1 = "AREALAND",
similar2 = "AREALAND", centroid = "population-weighted")
ratevars <- list(ratename = "pop_dens", numerator = "TOTAL_POP",
denominator = "AREALAND", multiplier = 10000,
colorname = "Greens")
exclist <- list(var1 = "B_TOT", var2 = "NONE", var3 = "NONE",
math1 = "equals", math2 = "equals", math3 = "equals",
val1 = 0, val2 = 0, val3 = 0, flagsum = 6)
filevars <- list(filein = "hftown", popfile = "hfblock",
fileout = "hftownagg5kbypopwt")
gatpkg::confirmGATbystep(gatvars = gatvars, ratevars = ratevars,
mergevars = mergevars, exclist = exclist,
filevars = filevars, savekml = FALSE, step = 11)
# code to generate window for locateGATshapefile.png
gatvars <- list(aggregator1 = "TOTAL_POP", aggregator2 = "TOTAL_POP",
myidvar = "ID", minvalue1 = 5000, minvalue2 = 5000,
boundary = "COUNTY", rigidbound = TRUE, popvar = "Pop_tot",
savekml = FALSE)
mergevars <- list(mergeopt1 = "closest", similar1 = "AREALAND",
similar2 = "AREALAND", centroid = "population-weighted")
ratevars <- list(ratename = "pop_dens", numerator = "TOTAL_POP",
denominator = "AREALAND", multiplier = 10000,
colorname = "Greens")
exclist <- list(var1 = "B_TOT", var2 = "NONE", var3 = "NONE",
math1 = "equals", math2 = "equals", math3 = "equals",
val1 = 0, val2 = 0, val3 = 0, flagsum = 6)
filevars <- list(filein = "hftown", popfile = "hfpop",
fileout = "hftown_agg5k15k_popwt",
userin = "C:/users/default/shapefiles/hftown",
userout = "C:/users/default/shapefiles/my_saves/hftown_agg5k15k_popwt")
gatpkg::confirmGATbystep(gatvars = gatvars, ratevars = ratevars,
mergevars = mergevars, exclist = exclist,
filevars = filevars, savekml = FALSE, step = 11)
confirmGATquit()
?confirmGATquit()
pathin <- paste0(find.package("gatpkg"), "/extdata")
mywtshp <- importGATweights(shp = hftown, filein = "hfblock", pathin)
pathin <- paste0(find.package("gatpkg"), "/extdata")
mywtshp <- importGATweights(area = hftown, filein = "hfpop", pathin)
pathin
pathin <- paste0(find.package("gatpkg"), "/extdata")
mywtshp <- importGATweights(area = hftown, filein = "hfblock", pathin)
?runGATprogram
devtools::check()
devtools::build()
remove.packages("gatpkg", lib="~/R/win-library/3.6")
install.packages(c("bookdown", "DT", "fs", "geojson", "htmlTable", "jsonlite", "knitr", "magick", "nloptr", "odbc", "openssl", "processx", "quanteda", "raster", "Rcpp", "RcppParallel", "renv", "rgdal", "rJava", "roxygen2", "shiny", "spData", "spdep", "tibble"))
devtools::build()
remove.packages("gatpkg", lib="~/R/win-library/3.6")
install.packages("P:/Sections/EHS/Abigail/SubcountyData/Rcode/gatpkg_1.51.tar.gz", repos = NULL, type = "source")
browseVignettes("gatpkg")
h <- gatpkg::hftown
hftown@data
h@data
library(tidyverse)
names(h)
h@data <- h@data %>% select(NAME_SHORT, COUNTY, AREALAND, AREAWATR, TOTAL_POP)
head(h@data)
h@data <- h@data %>% rename(TOWN = NAME_SHORT)
h <- gatpkg::hftown
h@data <- h@data %>% rename(TOWN = NAME_SHORT)
h@data <- h@data %>% select(TOWN, ID, COUNTY, AREALAND, AREAWATR, TOTAL_POP)
h@data <- h@data %>% mutate(MY_FLAG = ifelse(TOWN == "Caroga", 1, 0))
head(h@data)
rgdal::writeOGR(h, getwd(),
"hftown", driver = "ESRI Shapefile",
verbose = TRUE, overwrite_layer = TRUE)
knitr::include_graphics("images/identifyGATboundary.png")
knitr::include_graphics("images/identifyGATaggregators.png")
knitr::include_graphics("images/inputGATrate.png")
knitr::include_graphics("images/saveGATkml.png")
# fix this image and pre-select options
knitr::include_graphics("images/confirmGATdialog.png")
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::build()
citation("gatpkg")
remove.packages("gatpkg", lib="~/R/win-library/3.6")
install.packages(c("broom", "nloptr", "odbc", "pillar", "rJava", "rlang", "tibble"))
install.packages(c("odbc", "rJava"))
install.packages("P:/Sections/EHS/Abigail/SubcountyData/Rcode/gatpkg_1.52.tar.gz", repos = NULL, type = "source")
browseVignettes("gatpkg")
paste0(tools::getVignetteInfo("gatpkg", all = TRUE)[1, "Dir"], "/extdata/")
library(gatpkg)
citation("gatpkg")
runGATprogram()
knitr::include_graphics("images/inputGATrate.png")
runGATprogram(settings = "C:/Users/ajs11/Documents/hftown_agg5k15k_popwtsettings.Rdata")
devtools::check()
devtools::build()
remove.packages("gatpkg", lib="~/R/win-library/3.6")
install.packages("P:/Sections/EHS/Abigail/SubcountyData/Rcode/gatpkg_1.52.tar.gz", repos = NULL, type = "source")
browseVignettes("gatpkg")
devtools::build()
remove.packages("gatpkg", lib="~/R/win-library/3.6")
install.packages("P:/Sections/EHS/Abigail/SubcountyData/Rcode/gatpkg_1.52.tar.gz", repos = NULL, type = "source")
browseVignettes("gatpkg")
library(gatpkg)
hftown@data
hfagg5k@data
gatvars <- list(myidvar = "ID", aggregator1 = "TOTAL_POP",
aggregator2 = "TOTAL_POP", minvalue1 = 5000,
minvalue2 = 5000, boundary = "COUNTY",
rigidbound = TRUE, popwt = FALSE)
mergevars <- list(mergeopt1 = "closest", similar1 = "NONE",
similar2 = "NONE")
ratevars <- list(ratename = "no_rate") # not calculated
aggvars <- defineGATmerge(area = hftown, gatvars = gatvars,
mergevars = mergevars)
hfagg5k <- mergeGATareas(ratevars = ratevars, aggvars = aggvars,
idvar = gatvars$myidvar, myshp = hftown)
vars <- c("ID", "TOWN", "COUNTY", "AREALAND", "AREAWATR", "TOTAL_POP",
"MY_FLAG", "flag", "GATx", "GATy", "num_IDs")
hfagg5k@data <- hfagg5k@data[, names(hfagg5k@data)[names(hfagg5k@data) %in% vars]]
hfagg5k@data
hfagg5k <- mergeGATareas(ratevars = ratevars, aggvars = aggvars,
idvar = gatvars$myidvar, myshp = hftown)
names(hfagg5k)
vars <- c("ID", "TOWN", "COUNTY", "AREALAND", "AREAWATR", "TOTAL_POP",
"MY_FLAG", "GATflag", "GATx", "GATy", "GATnumIDs")
hfagg5k@data <- hfagg5k@data[, names(hfagg5k@data)[names(hfagg5k@data) %in% vars]]
hfagg5k@data
gatvars <- list(myidvar = "ID", aggregator1 = "TOTAL_POP",
aggregator2 = "TOTAL_POP", minvalue1 = 5000,
minvalue2 = 5000, boundary = "COUNTY",
rigidbound = TRUE, popwt = FALSE)
mergevars <- list(mergeopt1 = "closest", similar1 = "NONE",
similar2 = "NONE", centroid = "geographic")
ratevars <- list(ratename = "no_rate") # not calculated
aggvars <- defineGATmerge(area = hftown, gatvars = gatvars,
mergevars = mergevars)
hfagg5k <- mergeGATareas(ratevars = ratevars, aggvars = aggvars,
idvar = gatvars$myidvar, myshp = hftown)
vars <- c("ID", "TOWN", "COUNTY", "AREALAND", "AREAWATR", "TOTAL_POP",
"MY_FLAG", "GATflag", "GATx", "GATy", "GATnumIDs")
hfagg5k@data <- hfagg5k@data[, names(hfagg5k@data)[names(hfagg5k@data) %in% vars]]
hfagg5k@data
gatvars <- list(myidvar = "ID", aggregator1 = "TOTAL_POP",
aggregator2 = "TOTAL_POP", minvalue1 = 5000,
minvalue2 = 5000, boundary = "COUNTY",
rigidbound = TRUE, popwt = FALSE,
maxvalue1 = 15000, maxvalue2 = 15000)
mergevars <- list(mergeopt1 = "closest", similar1 = "NONE",
similar2 = "NONE", centroid = "geographic")
ratevars <- list(ratename = "no_rate") # not calculated
aggvars <- defineGATmerge(area = hftown, gatvars = gatvars,
mergevars = mergevars)
hfagg5k <- mergeGATareas(ratevars = ratevars, aggvars = aggvars,
idvar = gatvars$myidvar, myshp = hftown)
hfagg5k@data
?defineGATmerge
# to create hfagg5k ####
gatvars <- list(
myidvar = "ID",             # character variable of unique values
aggregator1 = "TOTAL_POP",  # numeric variable
aggregator2 = "TOTAL_POP",  # numeric variable
minvalue1 = 5000, minvalue2 = 5000,
maxvalue1 = 15000, maxvalue2 = 15000,
boundary = "COUNTY",        # character variable of non-unique values
rigidbound = TRUE,          # boolean to enforce boundary
popwt = FALSE,              # boolean for population weighting
popvar = "Pop_tot"          # aggregation variable in population laayer
)
mergevars <- list(
mergeopt1 = "similar",    # string can be similar, closest, or least
similar1 = "AREAWATR",    # numeric variable
similar2 = "AREALAND",    # numeric variable without any zeros
centroid = "geographic"
)
ratevars <- list(ratename = "no_rate") # not calculated
aggvars <- defineGATmerge(area = hftown, gatvars = gatvars,
mergevars = mergevars)
hfagg5k <- mergeGATareas(ratevars = ratevars, aggvars = aggvars,
idvar = gatvars$myidvar, myshp = hftown)
vars <- c("ID", "TOWN", "COUNTY", "AREALAND", "AREAWATR", "TOTAL_POP",
"MY_FLAG", "GATflag", "GATx", "GATy", "GATnumIDs")
hfagg5k@data <- hfagg5k@data[, names(hfagg5k@data)
[names(hfagg5k@data) %in% vars]]
hfagg5k@data
devtools::check()
devtools::build()
remove.packages("gatpkg", lib="~/R/win-library/3.6")
install.packages("P:/Sections/EHS/Abigail/SubcountyData/Rcode/gatpkg_1.52.tar.gz", repos = NULL, type = "source")
browseVignettes("gatpkg")
?gatpkg::hftown
gatpkg::hfagg5k@data
devtools::build()
remove.packages("gatpkg", lib="~/R/win-library/3.6")
install.packages("P:/Sections/EHS/Abigail/SubcountyData/Rcode/gatpkg_1.52.tar.gz", repos = NULL, type = "source")
library(gatpkg)
?hftown
?hfagg5k
hftown@data
devtools::build()
remove.packages("gatpkg", lib="~/R/win-library/3.6")
install.packages("P:/Sections/EHS/Abigail/SubcountyData/Rcode/gatpkg_1.52.tar.gz", repos = NULL, type = "source")
library(gatpkg)
?hftown
