agglist <- list(var1 = gatvars$aggregator1,
var2 = gatvars$aggregator2,
minval1 = gatvars$minvalue1,
maxval1 = gatvars$maxvalue1,
minval2 = gatvars$minvalue2,
maxval2 = gatvars$maxvalue2)
}
error <- TRUE
# re-call the function as needed
while (error) {
agglist <- identifyGATaggregators(mapdata = temp$mapdata,
step = step,
agglist = agglist,
backopt = !temp$flagconfirm)
error <- FALSE
if (is.null(agglist)) {
x <- confirmGATquit()
if (x == "quit") {
agglist <- list(var1 = "cancel")
} else {
error <- TRUE
agglist <- list(var1 = "")
}
} else if (length(agglist$var1) == 0) {
error <- TRUE
agglist <- NULL
}
}
if (agglist$var1 == "back") {
step <- step - 1
} else if (agglist$var1 == "cancel") {
step <- 20
mysettings$quit <- TRUE
} else if (!error) {
gatvars$aggregator1 <- agglist$var1
if (agglist$var2 == "NONE") {
gatvars$aggregator2 <- agglist$var1
} else {
gatvars$aggregator2 <- agglist$var2
}
gatvars$minvalue1 <- agglist$minval1
gatvars$maxvalue1 <- agglist$maxval1
gatvars$minvalue2 <- agglist$minval2
gatvars$maxvalue2 <- agglist$maxval2
if (temp$flagconfirm) {
step <- 11
} else {
step <- step + 1
}
}
if (agglist$maxval1 == sum(temp$mapdata[, agglist$var1], na.rm = TRUE)) {
gatvars$ismax1 <- TRUE
} else {
gatvars$ismax1 <- FALSE
}
if (!agglist$var2 == "NONE") {
if (agglist$maxval2 == sum(temp$mapdata[, agglist$var2], na.rm = TRUE)) {
gatvars$ismax2 <- TRUE
} else {
gatvars$ismax2 <- FALSE
}
if (agglist$minval2 == min(temp$mapdata[, agglist$var2], na.rm = TRUE)) {
gatvars$ismin2 <- TRUE
} else {
gatvars$ismin2 <- FALSE
}
}
rm(agglist)
} # end request aggregation variables (agglist)
while (step == 11) { # add dialog to confirm merge settings
pb <- list(title = "NYSDOH GAT: confirm settings",
label = "Confirming your GAT settings.")
tcltk::setTkProgressBar(tpb, value = step, title = pb$title,
label = pb$label)
# max value exclusions
temp$mapdata$GATflag <- calculateGATflag(exclist, temp$mapdata)
temp$mapdata$GATflag <-
ifelse(temp$mapdata[, gatvars$aggregator1] > as.numeric(gatvars$maxvalue1) &
temp$mapdata$GATflag == 0, 5, temp$mapdata$GATflag)
if (!gatvars$aggregator2 == gatvars$aggregator1) {
temp$mapdata$GATflag <-
ifelse(temp$mapdata[, gatvars$aggregator2] > as.numeric(gatvars$maxvalue2) &
temp$mapdata$GATflag == 0, 5, temp$mapdata$GATflag)
}
gatvars$exclmaxval <- sum(temp$mapdata$GATflag == 5)
temp$flagconfirm <- TRUE
error <- TRUE
gatvars$numrow <- nrow(temp$mapdata)
while (error) {
temp$cancel <- confirmGATbystep(gatvars = gatvars, ratevars = ratevars,
exclist = exclist, mergevars = mergevars,
filevars = filevars, step = step)
error <- FALSE
if (is.null(temp$cancel)) {
x <- confirmGATquit()
if (x == "quit") {
temp$cancel <- "Yes"
mysettings$quit <- TRUE
} else {
error <- TRUE
}
}
}
if (temp$cancel %in% c("Yes", "None")) {
step <- 20 # done with user input
myshps$original <- temp$shp
temp$shp@data <- temp$mapdata
} else if (temp$cancel == "back") { # now irrelevant
step <- step - 1 # go back one
} else if (temp$cancel == "cancel") {
step <- 20
mysettings$quit <- TRUE
} else if (grepl("[0-9]", temp$cancel)) {
step <- as.numeric(gsub("[^0-9]", "", temp$cancel))
}
} # end request settings confirmation (filein)
temp$mapdata$GATflag <- calculateGATflag(exclist, temp$mapdata)
table(temp$mapdata$GATflag)
temp$mapdata$GATflag <- 0
table(temp$mapdata$GATflag)
temp$mapdata$GATflag <- calculateGATflag(exclist, temp$mapdata)
table(temp$mapdata$GATflag)
temp$mapdata$GATflag <-
ifelse(temp$mapdata[, gatvars$aggregator1] > as.numeric(gatvars$maxvalue1) &
temp$mapdata$GATflag == 0, 5, temp$mapdata$GATflag)
table(temp$mapdata$GATflag)
if (!gatvars$aggregator2 == gatvars$aggregator1) {
temp$mapdata$GATflag <-
ifelse(temp$mapdata[, gatvars$aggregator2] > as.numeric(gatvars$maxvalue2) &
temp$mapdata$GATflag == 0, 5, temp$mapdata$GATflag)
}
table(temp$mapdata$GATflag)
gatvars$exclmaxval <- sum(temp$mapdata$GATflag == 5)
gatvars$exclmaxval
while (step == 4) { # ask for aggregation variables
pb <- list(title = "NYSDOH GAT: identify aggregators",
label = "Selecting the aggregation variables.")
tcltk::setTkProgressBar(tpb, value = step, title = pb$title,
label = pb$label)
if (is.null(gatvars$aggregator1)) {
agglist <- NULL
} else {
agglist <- list(var1 = gatvars$aggregator1,
var2 = gatvars$aggregator2,
minval1 = gatvars$minvalue1,
maxval1 = gatvars$maxvalue1,
minval2 = gatvars$minvalue2,
maxval2 = gatvars$maxvalue2)
}
error <- TRUE
# re-call the function as needed
while (error) {
agglist <- identifyGATaggregators(mapdata = temp$mapdata,
step = step,
agglist = agglist,
backopt = !temp$flagconfirm)
error <- FALSE
if (is.null(agglist)) {
x <- confirmGATquit()
if (x == "quit") {
agglist <- list(var1 = "cancel")
} else {
error <- TRUE
agglist <- list(var1 = "")
}
} else if (length(agglist$var1) == 0) {
error <- TRUE
agglist <- NULL
}
}
if (agglist$var1 == "back") {
step <- step - 1
} else if (agglist$var1 == "cancel") {
step <- 20
mysettings$quit <- TRUE
} else if (!error) {
gatvars$aggregator1 <- agglist$var1
if (agglist$var2 == "NONE") {
gatvars$aggregator2 <- agglist$var1
} else {
gatvars$aggregator2 <- agglist$var2
}
gatvars$minvalue1 <- agglist$minval1
gatvars$maxvalue1 <- agglist$maxval1
gatvars$minvalue2 <- agglist$minval2
gatvars$maxvalue2 <- agglist$maxval2
if (temp$flagconfirm) {
step <- 11
} else {
step <- step + 1
}
}
if (agglist$maxval1 == sum(temp$mapdata[, agglist$var1], na.rm = TRUE)) {
gatvars$ismax1 <- TRUE
} else {
gatvars$ismax1 <- FALSE
}
if (!agglist$var2 == "NONE") {
if (agglist$maxval2 == sum(temp$mapdata[, agglist$var2], na.rm = TRUE)) {
gatvars$ismax2 <- TRUE
} else {
gatvars$ismax2 <- FALSE
}
if (agglist$minval2 == min(temp$mapdata[, agglist$var2], na.rm = TRUE)) {
gatvars$ismin2 <- TRUE
} else {
gatvars$ismin2 <- FALSE
}
}
rm(agglist)
} # end request aggregation variables (agglist)
while (step == 11) { # add dialog to confirm merge settings
pb <- list(title = "NYSDOH GAT: confirm settings",
label = "Confirming your GAT settings.")
tcltk::setTkProgressBar(tpb, value = step, title = pb$title,
label = pb$label)
# max value exclusions
temp$mapdata$GATflag <- 0
temp$mapdata$GATflag <- calculateGATflag(exclist, temp$mapdata)
temp$mapdata$GATflag <-
ifelse(temp$mapdata[, gatvars$aggregator1] > as.numeric(gatvars$maxvalue1) &
temp$mapdata$GATflag == 0, 5, temp$mapdata$GATflag)
if (!gatvars$aggregator2 == gatvars$aggregator1) {
temp$mapdata$GATflag <-
ifelse(temp$mapdata[, gatvars$aggregator2] > as.numeric(gatvars$maxvalue2) &
temp$mapdata$GATflag == 0, 5, temp$mapdata$GATflag)
}
gatvars$exclmaxval <- sum(temp$mapdata$GATflag == 5)
temp$flagconfirm <- TRUE
error <- TRUE
gatvars$numrow <- nrow(temp$mapdata)
while (error) {
temp$cancel <- confirmGATbystep(gatvars = gatvars, ratevars = ratevars,
exclist = exclist, mergevars = mergevars,
filevars = filevars, step = step)
error <- FALSE
if (is.null(temp$cancel)) {
x <- confirmGATquit()
if (x == "quit") {
temp$cancel <- "Yes"
mysettings$quit <- TRUE
} else {
error <- TRUE
}
}
}
if (temp$cancel %in% c("Yes", "None")) {
step <- 20 # done with user input
myshps$original <- temp$shp
temp$shp@data <- temp$mapdata
} else if (temp$cancel == "back") { # now irrelevant
step <- step - 1 # go back one
} else if (temp$cancel == "cancel") {
step <- 20
mysettings$quit <- TRUE
} else if (grepl("[0-9]", temp$cancel)) {
step <- as.numeric(gsub("[^0-9]", "", temp$cancel))
}
} # end request settings confirmation (filein)
confirmGATbystep <- function(gatvars, ratevars, mergevars, filevars, exclist,
savekml, step = 0) {
## initial settings ####
instruct <- paste("To modify a step, choose it from the list and click",
"'Confirm'. \n After you modify most steps, you will",
"return to this dialog. \n",
"If you modify Step 1, GAT will start over.")
fonthead <- tcltk2::tk2font.set(font = "fonthead", settings = list(family = "Segoe UI",
size = 10, bold = TRUE, italic = FALSE))
stepslist <- c("1. File to aggregate",
"2. Identifying variable",
"3. Boundary variable",
"4. Minimum and maximum values",
"5. Exclusion criteria",
"6. Merge type",
"7. Population file",
"8. Rate calculation",
"9. Save KML file",
"10. Save location",
"None")
## set up window ####
tt <- tcltk::tktoplevel()
tcltk::tktitle(tt) <- paste0("Step ", step, ": Review settings")
## define GAT settings ####
mysets <- paste0("  ", stepslist[1], ": ", filevars$userin, " \n",
"  ", stepslist[2], ": ", gatvars$myidvar, " \n",
"  ", stepslist[3], ":")
if (gatvars$boundary != "NONE") {
mysets <- paste(mysets, gatvars$boundary)
if (gatvars$rigidbound) {
mysets <- paste(mysets, "required \n")
} else {
mysets <- paste(mysets, "not required \n")
}
} else {
mysets <- paste(mysets, "None selected \n")
}
### aggregation variables ####
min1 <- format(as.numeric(gsub(",", "", gatvars$minvalue1)),
big.mark=",", scientific=FALSE)
if (gatvars$ismax1) {
max1 <- "maximum"
} else {
max1 <- format(as.numeric(gsub(",", "", gatvars$maxvalue1)),
big.mark=",", scientific=FALSE)
}
mysets <- paste0(mysets, "  ", stepslist[4], ": \n",
paste(rep(" ", 17), collapse = ""),
min1 , " to ", max1, " ", gatvars$aggregator1, "\n")
if (!gatvars$aggregator2 %in% c(gatvars$aggregator1, "NONE")) {
if (gatvars$ismin2) {
min2 <- "minimum"
} else {
min2 <- format(as.numeric(gsub(",", "", gatvars$minvalue2)),
big.mark=",", scientific=FALSE)
}
if (gatvars$ismax2) {
max2 <- "maximum"
} else {
max2 <- format(as.numeric(gsub(",", "", gatvars$maxvalue2)),
big.mark=",", scientific=FALSE)
}
mysets <- paste(mysets, paste(rep(" ", 15), collapse = ""),
min2, "to", max2, gatvars$aggregator2, "\n")
}
mysets <- paste(mysets, paste(rep(" ", 10), collapse = ""),
"Areas excluded (value over maximum):", gatvars$exclmaxval, "of",
gatvars$numrow, "\n")
### exclusions ####
mysets <- paste0(mysets, "  ", stepslist[5], ":")
if (exclist$var1 != "NONE" | exclist$var1 != "NONE" |
exclist$var1 != "NONE") {
if (exclist$var1 != "NONE") {
mysets <- paste(mysets, exclist$var1, exclist$math1, exclist$val1, "\n")
}
if (exclist$var2 != "NONE") {
mysets <- paste(mysets, paste(rep(" ", 36), collapse = ""),
exclist$var2, exclist$math2, exclist$val2, "\n")
}
if (exclist$var3 != "NONE") {
mysets <- paste(mysets, paste(rep(" ", 36), collapse = ""),
exclist$var3, exclist$math3, exclist$val3, "\n")
}
mysets <- paste(mysets, paste(rep(" ", 10), collapse = ""),
"Areas excluded:", exclist$flagsum, "of", gatvars$numrow, "\n")
} else {
mysets <- paste(mysets, "None selected \n")
}
### merge type ####
mysets <- paste0(mysets, "  ", stepslist[6], ":")
if (mergevars$mergeopt1 == "closest") {
mysets <- paste(mysets, "Closest", mergevars$centroid, "centroid \n")
} else if (mergevars$mergeopt1 == "least") {
mysets <- paste(mysets, "Adjacent area with the fewest", gatvars$aggregator1, "\n")
} else if (mergevars$mergeopt1 == "similar") {
mysets <- paste(mysets, "Adjacent area with the closest value of \n",
paste(rep(" ", 27), collapse = ""),
mergevars$similar1, "/", mergevars$similar2, "\n")
}
### population weighting ####
mysets <- paste0(mysets, "  ", stepslist[7], ":")
if (mergevars$centroid == "population-weighted") {
mysets <- paste(mysets, filevars$popfile, "\n",
paste(rep(" ", 10), collapse = ""),
"Population variable:", gatvars$popvar, "\n")
} else {
mysets <- paste(mysets, "Population weighting not selected \n")
}
### rate settings ####
mysets <- paste0(mysets, "  ", stepslist[8], ":")
if (ratevars$ratename == "no_rate") {
mysets <- paste(mysets, "Not selected \n")
} else {
mysets <- paste(mysets, ratevars$ratename, "=",
format(as.numeric(ratevars$multiplier), big.mark=",",
scientific=FALSE),
"*", ratevars$numerator, "/", ratevars$denominator, "\n",
paste(rep(" ", 10), collapse = ""),
"Color scheme:", ratevars$colorname, "\n")
}
### save kml ####
mysets <- paste0(mysets, "  ", stepslist[9], "?")
if (gatvars$savekml) {
mysets <- paste(mysets, "Yes \n")
} else {
mysets <- paste(mysets, "No \n")
}
### save location ####
mysets <- paste0(mysets, stepslist[10], ": ", filevars$userout)
## print GAT settings ####
tt$ins <- tcltk2::tk2label(tt, text = mysets)
tcltk::tkgrid(tt$ins, sticky = "w", padx = 5, pady = 5)
tt$insttl <- tcltk2::tk2label(tt, text = "Instructions", font = "fonthead")
tcltk::tkgrid(tt$insttl, sticky = "w", padx = 5, pady = 5)
tt$ins <- tcltk2::tk2label(tt, text = instruct)
tcltk::tkgrid(tt$ins, sticky = "w", padx = 5, pady = 5)
## request step selection ####
tt$stepdir <- tcltk::tkframe(tt)
stepvar <- tcltk::tclVar("None")
tt$stepdir$stepq <- tcltk2::tk2label(tt$stepdir,
text = "Select the setting you wish to modify:")
tt$stepdir$steplist <- tcltk::ttkcombobox(tt$stepdir, values = stepslist,
textvariable = stepvar, state = "readonly")
tcltk::tkgrid(tt$stepdir$stepq, tt$stepdir$steplist, sticky = "w",
padx = 5, pady = 5)
tcltk::tkgrid(tt$stepdir)
## help settings ####
helppage <- "confirmGATbystep"
hlp <- paste0("To continue, select a step to modify, \n",
"or 'None' if you are finished, then click 'Confirm'. \n",
"To start over, select Step 1.")
myenv <- new.env()
# button functions and layout
onHelp <- function() {
showGAThelp(help = hlp, helptitle = helppage, helppage = helppage,
step = step)
}
onOk <- function() {
Rbval <- tcltk::tclvalue(stepvar)
tcltk::tkdestroy(tt)
assign("myvalue", Rbval, envir=myenv)
}
onCancel <- function() {
tcltk::tkdestroy(tt)
assign("myvalue", "cancel", envir=myenv)
}
# draw buttons
tt$tf <- tcltk::tkframe(tt)
tt$tf$HelpBut <- tcltk2::tk2button(tt$tf, text="Help",
width = 12, command = onHelp)
tt$tf$OkBut <- tcltk2::tk2button(tt$tf, text = "Confirm",
width = 12, command = onOk,
default = "active")
tt$tf$CancelBut <- tcltk2::tk2button(tt$tf, text = "Cancel GAT",
width = 12, command = onCancel)
tcltk::tkgrid(tt$tf$OkBut, column = 2, row = 1, padx = 5)
tcltk::tkgrid(tt$tf$CancelBut, column = 3, row = 1, padx = 5)
tcltk::tkgrid(tt$tf$HelpBut, column = 4, row = 1, padx = 5)
tcltk::tkgrid(tt$tf, padx = 1, pady = 5)
# wait to continue ####
tcltk::tkwait.window(tt)
return(myenv$myvalue)
}
step=11
while (step == 11) { # add dialog to confirm merge settings
pb <- list(title = "NYSDOH GAT: confirm settings",
label = "Confirming your GAT settings.")
tcltk::setTkProgressBar(tpb, value = step, title = pb$title,
label = pb$label)
# max value exclusions
temp$mapdata$GATflag <- 0
temp$mapdata$GATflag <- calculateGATflag(exclist, temp$mapdata)
temp$mapdata$GATflag <-
ifelse(temp$mapdata[, gatvars$aggregator1] > as.numeric(gatvars$maxvalue1) &
temp$mapdata$GATflag == 0, 5, temp$mapdata$GATflag)
if (!gatvars$aggregator2 == gatvars$aggregator1) {
temp$mapdata$GATflag <-
ifelse(temp$mapdata[, gatvars$aggregator2] > as.numeric(gatvars$maxvalue2) &
temp$mapdata$GATflag == 0, 5, temp$mapdata$GATflag)
}
gatvars$exclmaxval <- sum(temp$mapdata$GATflag == 5)
temp$flagconfirm <- TRUE
error <- TRUE
gatvars$numrow <- nrow(temp$mapdata)
while (error) {
temp$cancel <- confirmGATbystep(gatvars = gatvars, ratevars = ratevars,
exclist = exclist, mergevars = mergevars,
filevars = filevars, step = step)
error <- FALSE
if (is.null(temp$cancel)) {
x <- confirmGATquit()
if (x == "quit") {
temp$cancel <- "Yes"
mysettings$quit <- TRUE
} else {
error <- TRUE
}
}
}
if (temp$cancel %in% c("Yes", "None")) {
step <- 20 # done with user input
myshps$original <- temp$shp
temp$shp@data <- temp$mapdata
} else if (temp$cancel == "back") { # now irrelevant
step <- step - 1 # go back one
} else if (temp$cancel == "cancel") {
step <- 20
mysettings$quit <- TRUE
} else if (grepl("[0-9]", temp$cancel)) {
step <- as.numeric(gsub("[^0-9]", "", temp$cancel))
}
} # end request settings confirmation (filein)
exists(gatvars$hyt)
exists("gatvars$hyt")
exists("gatvars$ismax1")
gatvars$gy
?citation
citation("gatpkg", auto = meta)
citation("gatpkg", auto = "meta")
?readCitationFile
readCitationFile("gatpkg", meta = "Authors@R")
?packageVersion
packageDescription(
"gatpkg"
)
x <- packageDescription(
"gatpkg"
)
str(x)
x$`Authors@R`
x$Author
print(x$Author)
40*7.5
