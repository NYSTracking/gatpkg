if (!is.null(gatvars$maxvalue1)) {
temp$aggdata <- temp$aggdata[which(
temp$aggdata[, gatvars$aggregator1] + temp$first[, gatvars$aggregator1] <
as.numeric(gsub(",", "", gatvars$maxvalue1)) |
temp$aggdata[, gatvars$aggregator2] + temp$first[, gatvars$aggregator2] <
as.numeric(gsub(",", "", gatvars$maxvalue2))), ]
}
townvars$townnbid <- attr(townvars$townnb, "region.id")
if (gatvars$boundary != "NONE") {
temp$firstboundary <- as.character(temp$first[, gatvars$boundary])
} else {
temp$firstboundary <- "NONE"
}
if (temp$first[, gatvars$myidvar] %in% townvars$townnbid) {
townvars$townnbidloc <- which(townvars$townnbid ==
temp$first[, gatvars$myidvar])
# try a different way: result is neighbors as integer ####
townvars$neighbors <- townvars$townnb[[townvars$townnbidloc]]
townvars$neighborid <- townvars$townnbid[townvars$neighbors]
townvars$nbdata <-
temp$aggdata[which(temp$aggdata[, gatvars$myidvar] %in%
townvars$neighborid), ]
if (gatvars$boundary != "NONE") { # gatvars$rigidbound?
townvars$nbdata <- townvars$nbdata[which(
townvars$nbdata[, gatvars$boundary] == temp$firstboundary), ]
}
}
# 7 areas have no neighbors, define nbdata in next if statement
# get the data about these neighbors ####
if (gatvars$boundary != "NONE") {
if (temp$firstboundary %in% townvars$nbdata[, gatvars$boundary]) {
# index of neighbors in same county
temp$inco_dex <- which(townvars$nbdata[, gatvars$boundary] ==
temp$firstboundary)
# can't use subset function with variable for variable name
temp$inco_nbdata <- townvars$nbdata[temp$inco_dex, ]
temp$inco_nbrows <- nrow(temp$inco_nbdata)
} else {
temp$inco_nbrows <- 0
}
# use observations in same county if possible, even if not adjacent ####
if (temp$inco_nbrows > 0) {
townvars$nbdata <- temp$inco_nbdata
} else {
if (temp$logmsg == "") {
temp$logmsg <- paste0("Merge ", aggvars$newregno + maxid, " (",
temp$first[, gatvars$myidvar], "):")
}
temp$logmsg <- paste(temp$logmsg,
"No physically adjacent neighbors",
"found within the same boundary.")
if (!adjacent & gatvars$boundary != "NONE") {
# get all in same county, first index then the data
temp$inco_alldex <- which(temp$aggdata[, gatvars$boundary] ==
temp$firstboundary &
temp$aggdata[, gatvars$myidvar] !=
temp$first[, gatvars$myidvar])
temp$inco_alldata <- temp$aggdata[temp$inco_alldex, ]
if(nrow(temp$inco_alldata) > 0){
townvars$nbdata <- temp$inco_alldata
mergevars$mergeopt2 <- "closest"
temp$logmsg <- paste(temp$logmsg,
"Found areas in the same boundary,",
"but they are not physically adjacent.")
}
}
}
} # end if boundarvar is not NONE
# if no adjacent neighbors found, any area is a candidate for merging ####
if(nrow(townvars$nbdata) == 0) {
if (temp$logmsg == "") {
temp$logmsg <- paste0("Merge ", aggvars$newregno + maxid, " (",
temp$first[, gatvars$myidvar], "):")
}
temp$logmsg <- paste(temp$logmsg,
"No physically adjacent neighbors found.")
if (!adjacent) {
# don't want to use least or similar if no adjacent neighbors
mergevars$mergeopt2 <- "closest"
townvars$nbdata <-
temp$aggdata[which(temp$aggdata[, gatvars$myidvar] %in%
townvars$neighborid), ]
if (gatvars$rigidbound) {
temp$inco_dex <- which(townvars$nbdata[, gatvars$boundary] ==
temp$firstboundary)
# can't use subset function with variable for variable name
townvars$nbdata <- townvars$nbdata[temp$inco_dex, ]
}
}
}
# if no adjacent neighbors in boundary, look elsewhere ####
if(nrow(townvars$nbdata) == 0) {
if (temp$logmsg == "") {
temp$logmsg <- paste0("Merge ", aggvars$newregno + maxid, " (",
temp$first[, gatvars$myidvar], "):")
}
temp$logmsg <- paste(temp$logmsg,
"No neighbors found in boundary.")
if (!adjacent & !gatvars$rigidbound) {
townvars$townnbid <- attr(townvars$townnb, "region.id")
# don't want to use least or similar if no adjacent neighbors
if (temp$first[, gatvars$myidvar] %in% townvars$townnbid) {
townvars$townnbidloc <- which(townvars$townnbid ==
temp$first[, gatvars$myidvar])
# try a different way: result is neighbors as integer ####
townvars$neighbors <- townvars$townnb[[townvars$townnbidloc]]
townvars$neighborid <- townvars$townnbid[townvars$neighbors]
townvars$nbdata <-
temp$aggdata[which(temp$aggdata[, gatvars$myidvar] %in%
townvars$neighborid), ]
}
}
}
# quit searching for neighbors ####
if(nrow(townvars$nbdata) == 0) {
# GATflag = "skip me" then at beginning of loop, check for and remove flags ####
# (can also remove oversized, etc at that point)
# - assign them in previous step
aggvars$allpolydata$GATflag[aggvars$allpolydata[, gatvars$myidvar] ==
temp$first[, gatvars$myidvar]] <- 10
if (temp$logmsg == "") {
temp$logmsg <- paste0("Merge ", aggvars$newregno + maxid, " (",
temp$first[, gatvars$myidvar], "):")
}
temp$logmsg <- paste(temp$logmsg, "No remaining neighbors.",
"This area cannot be merged further.")
} else {
# rank centroid distances ####
townvars$nborder <- rankGATdistance(area = area,
nbdata = townvars$nbdata,
first = temp$first,
gatvars = gatvars,
mergevars = mergevars)
# data which will be combined to form new region ####
townvars$newreg <- rbind(temp$first,
townvars$nbdata[townvars$nborder[1], ])
# add leading zeroes based on maximum number of areas
temp$zero <- paste(rep("0", temp$digits -
nchar(aggvars$newregno + maxid)),
collapse = "")
townvars$nrid <- paste0("GATid_", temp$zero,
as.character(aggvars$newregno + maxid))
temp$IDloc <- which(aggvars$IDlist %in% townvars$newreg[, gatvars$myidvar])
aggvars$IDlist[temp$IDloc] <- townvars$nrid
# calculate new region ####
townvars$newregdata <- createGATregion(mydata = aggvars$allpolydata,
newreg = townvars$newreg,
myidvar = gatvars$myidvar,
nrid = townvars$nrid,
area = area, pop = mapvars$pop,
IDlist = aggvars$IDlist,
pwrepeat = pwrepeat,
popwt = gatvars$popwt)
# add the new region to the list of data about the regions ####
aggvars$allpolydata <- rbind(aggvars$allpolydata, townvars$newregdata)
# need to remove the info about the old regions
aggvars$allpolydata <-
aggvars$allpolydata[which(!aggvars$allpolydata[, gatvars$myidvar] %in%
townvars$newreg[, gatvars$myidvar]), ]
# use spdep::aggregate.nb to create new object listing neighbors of aggregate
townvars$townnb <- spdep::aggregate.nb(townvars$oldtownnb, aggvars$IDlist)
aggvars$newregno <- aggvars$newregno + 1
}
# find the minimum population ####
temp$minpop1 <- min(aggvars$allpolydata[which(aggvars$allpolydata$GATflag == 0),
gatvars$aggregator1])
temp$minpop2 <- min(aggvars$allpolydata[which(aggvars$allpolydata$GATflag == 0),
gatvars$aggregator2])
if (temp$logmsg != "") {
aggvars$logmsg <- paste0(aggvars$logmsg, temp$logmsg, "\n")
}
}
# if function is isolated, close progress bar that monitors the aggregation
close(tmb)
return(aggvars)
}
gatvars <- list(
myidvar = "ID",             # character variable of unique values
aggregator1 = "TOTAL_POP",  # numeric variable
aggregator2 = "TOTAL_POP",  # numeric variable
minvalue1 = 10000, minvalue2 = 10000,
maxvalue1 = 40000, maxvalue2 = 40000,
boundary = "COUNTY",        # character variable of non-unique values
rigidbound = FALSE,          # boolean to enforce boundary
popwt = FALSE,              # boolean for population weighting
popvar = "Pop_tot"          # aggregation variable in population laayer
)
mergevars <- list(
mergeopt1 = "similar",    # string can be similar, closest, or least
similar1 = "B_TOT",       # numeric variable
similar2 = "W_TOT",        # numeric variable without any zeros
centroid = "geographic"
)
filevars <- list(
popfile = "hfblock",
poppath = paste0(find.package("gatpkg"), "/extdata")
)
my_merge <-
defineGATmerge(
area = hftown,
gatvars = gatvars,
mergevars = mergevars,
filevars = filevars, adjacent = TRUE,
pwrepeat = FALSE # don't need pwrepeat if popwt = FALSE
)
my_merge
defineGATmerge <- function(area, gatvars, mergevars, filevars, pwrepeat = FALSE,
adjacent = TRUE) {
# temp until it's programmed in ####
if (!"GATflag" %in% names(area@data)) {
area@data$GATflag <- 0 # for non-default uses of this function
}
if (gatvars$aggregator2 == "NONE") {
gatvars$aggregator2 <- gatvars$aggregator1
}
# draw window ####
mb <- list(label = "Preparing merge files. Please wait.",
title = "NYSDOH GAT: merging")
tmb <- tcltk::tkProgressBar(title = mb$title, label = mb$label, min = 0,
max = nrow(area@data), initial = 0, width = 400)
# if projection is lat/lon, projection = TRUE, otherwise FALSE
mapvars <- list(projection = grepl("longlat",
sp::proj4string(area), fixed = TRUE))
# set up centroids ####
# find a way to not hit memory limit for population weighting
if (gatvars$popwt) {
# may need to assign ID as row names
mb$label = "Loading population file. This step may be slow."
tcltk::setTkProgressBar(tmb, value = 0, title = mb$title,
label = mb$label)
temp <- weightGATmap(area = area, popvar = gatvars$popvar,
filevars = filevars, idvar = gatvars$myidvar)
mapvars$centroids <- temp$centroids
mapvars$pop <- temp$pop
# area@data$GATpop <- mapvars$centroids$GATpop
} else {
mapvars$centroids <- sp::coordinates(area)
colnames(mapvars$centroids) <- c("GATx", "GATy")
mapvars$pop <- NULL
}
# default to not lat/long if something goes wrong
if (is.na(mapvars$projection)) mapvars$projection <- FALSE
# add centroids to polygon data ####
aggvars <- list(IDlist = as.character(area@data[, gatvars$myidvar]),
allpolydata = data.frame(area@data, mapvars$centroids),
newregno = 1,
logmsg = "") # record merge warnings in the log)
# set up temporary variables ####
if (gatvars$aggregator2 == "NONE") gatvars$aggregator2 <- gatvars$aggregator1
temp <- list(rownames = area@data[, gatvars$myidvar],
minpop1 = min(aggvars$allpolydata[which(aggvars$allpolydata$GATflag == 0),
gatvars$aggregator1]),
minpop2 = min(aggvars$allpolydata[which(aggvars$allpolydata$GATflag == 0),
gatvars$aggregator2]),
index = sapply(aggvars$allpolydata, is.integer),
digits = nchar(nrow(aggvars$allpolydata)))
myids <- as.character(unlist(data.frame(area@data[, gatvars$myidvar])))
myids <- myids[grepl("GATid", myids)]
myids <- gsub("GATid_", "",  myids)
if (length(myids) == 0) {
maxid <- 0
} else {
maxid <- max(as.numeric(myids))
temp$digits <- nchar(myids[1])
}
# set up town variables ####
# get list of neighbors using poly2nb method from spdep packagetow
townvars <- list(oldtownnb = spdep::poly2nb(area, queen = FALSE,
row.names = temp$rownames),
townnb = spdep::poly2nb(area, queen = FALSE,
row.names = temp$rownames))
# convert integers to double (change to convert when I read in file?)
aggvars$allpolydata[, temp$index] <-
sapply(aggvars$allpolydata[, temp$index], as.numeric)
# start while loop ####
while ((temp$minpop1 < gatvars$minvalue1) |
(temp$minpop2 < gatvars$minvalue2)){
# start loop ####
temp$logmsg <- ""
temp$aggdata <- aggvars$allpolydata[which(aggvars$allpolydata$GATflag == 0), ]
# change the merge order low to high
temp$tobemerged <- temp$aggdata[which(
(temp$aggdata[, gatvars$aggregator1] < gatvars$minvalue1) |
(temp$aggdata[, gatvars$aggregator2] < gatvars$minvalue2) ), ]
if (temp$minpop1 < gatvars$minvalue1) {
temp$tobemerged <- temp$tobemerged[order(-temp$tobemerged[, gatvars$aggregator1]), ]
} else {
temp$tobemerged <- temp$tobemerged[order(-temp$tobemerged[, gatvars$aggregator2]), ]
}
# incremental progress bar ####
mb$label <- paste0("Merge ", aggvars$newregno + maxid, ": ",
nrow(temp$tobemerged), " areas remaining.")
step <- nrow(area@data) - nrow(temp$tobemerged)
tcltk::setTkProgressBar(tmb, value = step, title = mb$title,
label = mb$label)
# default merge option is the one selected ####
mergevars$mergeopt2 <- mergevars$mergeopt1
temp$first <- identifyGATfirstobs(tobemerged = temp$tobemerged,
aggvar = gatvars$aggregator1,
aggvar2 = gatvars$aggregator2,
minval = gatvars$minvalue1,
minval2 = gatvars$minvalue2)
if (!is.null(gatvars$maxvalue1)) {
temp$aggdata <- temp$aggdata[which(
temp$aggdata[, gatvars$aggregator1] + temp$first[, gatvars$aggregator1] <
as.numeric(gsub(",", "", gatvars$maxvalue1)) |
temp$aggdata[, gatvars$aggregator2] + temp$first[, gatvars$aggregator2] <
as.numeric(gsub(",", "", gatvars$maxvalue2))), ]
}
townvars$townnbid <- attr(townvars$townnb, "region.id")
if (gatvars$boundary != "NONE") {
temp$firstboundary <- as.character(temp$first[, gatvars$boundary])
} else {
temp$firstboundary <- "NONE"
}
if (temp$first[, gatvars$myidvar] %in% townvars$townnbid) {
townvars$townnbidloc <- which(townvars$townnbid ==
temp$first[, gatvars$myidvar])
# try a different way: result is neighbors as integer ####
townvars$neighbors <- townvars$townnb[[townvars$townnbidloc]]
townvars$neighborid <- townvars$townnbid[townvars$neighbors]
townvars$nbdata <-
temp$aggdata[which(temp$aggdata[, gatvars$myidvar] %in%
townvars$neighborid), ]
if (gatvars$boundary != "NONE") { # gatvars$rigidbound?
townvars$nbdata <- townvars$nbdata[which(
townvars$nbdata[, gatvars$boundary] == temp$firstboundary), ]
}
}
# 7 areas have no neighbors, define nbdata in next if statement
# get the data about these neighbors ####
if (gatvars$boundary != "NONE") {
if (temp$firstboundary %in% townvars$nbdata[, gatvars$boundary]) {
# index of neighbors in same county
temp$inco_dex <- which(townvars$nbdata[, gatvars$boundary] ==
temp$firstboundary)
# can't use subset function with variable for variable name
temp$inco_nbdata <- townvars$nbdata[temp$inco_dex, ]
temp$inco_nbrows <- nrow(temp$inco_nbdata)
} else {
temp$inco_nbrows <- 0
}
# use observations in same county if possible, even if not adjacent ####
if (temp$inco_nbrows > 0) {
townvars$nbdata <- temp$inco_nbdata
} else {
if (temp$logmsg == "") {
temp$logmsg <- paste0("Merge ", aggvars$newregno + maxid, " (",
temp$first[, gatvars$myidvar], "):")
}
temp$logmsg <- paste(temp$logmsg,
"No physically adjacent neighbors",
"found within the same boundary.")
if (!adjacent & gatvars$boundary != "NONE") {
# get all in same county, first index then the data
temp$inco_alldex <- which(temp$aggdata[, gatvars$boundary] ==
temp$firstboundary &
temp$aggdata[, gatvars$myidvar] !=
temp$first[, gatvars$myidvar])
temp$inco_alldata <- temp$aggdata[temp$inco_alldex, ]
if(nrow(temp$inco_alldata) > 0){
townvars$nbdata <- temp$inco_alldata
mergevars$mergeopt2 <- "closest"
temp$logmsg <- paste(temp$logmsg,
"Found areas in the same boundary,",
"but they are not physically adjacent.")
}
}
}
} # end if boundarvar is not NONE
# if no adjacent neighbors found, any area is a candidate for merging ####
if(nrow(townvars$nbdata) == 0) {
if (temp$logmsg == "") {
temp$logmsg <- paste0("Merge ", aggvars$newregno + maxid, " (",
temp$first[, gatvars$myidvar], "):")
}
temp$logmsg <- paste(temp$logmsg,
"No physically adjacent neighbors found.")
if (!adjacent) {
# don't want to use least or similar if no adjacent neighbors
mergevars$mergeopt2 <- "closest"
townvars$nbdata <-
temp$aggdata[which(temp$aggdata[, gatvars$myidvar] %in%
townvars$neighborid), ]
if (gatvars$rigidbound) {
temp$inco_dex <- which(townvars$nbdata[, gatvars$boundary] ==
temp$firstboundary)
# can't use subset function with variable for variable name
townvars$nbdata <- townvars$nbdata[temp$inco_dex, ]
}
}
}
# if no adjacent neighbors in boundary, look elsewhere ####
if(nrow(townvars$nbdata) == 0) {
if (temp$logmsg == "") {
temp$logmsg <- paste0("Merge ", aggvars$newregno + maxid, " (",
temp$first[, gatvars$myidvar], "):")
}
temp$logmsg <- paste(temp$logmsg,
"No neighbors found in boundary.")
if (adjacent & !gatvars$rigidbound) {
townvars$townnbid <- attr(townvars$townnb, "region.id")
# don't want to use least or similar if no adjacent neighbors
if (temp$first[, gatvars$myidvar] %in% townvars$townnbid) {
townvars$townnbidloc <- which(townvars$townnbid ==
temp$first[, gatvars$myidvar])
# try a different way: result is neighbors as integer ####
townvars$neighbors <- townvars$townnb[[townvars$townnbidloc]]
townvars$neighborid <- townvars$townnbid[townvars$neighbors]
townvars$nbdata <-
temp$aggdata[which(temp$aggdata[, gatvars$myidvar] %in%
townvars$neighborid), ]
}
}
}
# quit searching for neighbors ####
if(nrow(townvars$nbdata) == 0) {
# GATflag = "skip me" then at beginning of loop, check for and remove flags ####
# (can also remove oversized, etc at that point)
# - assign them in previous step
aggvars$allpolydata$GATflag[aggvars$allpolydata[, gatvars$myidvar] ==
temp$first[, gatvars$myidvar]] <- 10
if (temp$logmsg == "") {
temp$logmsg <- paste0("Merge ", aggvars$newregno + maxid, " (",
temp$first[, gatvars$myidvar], "):")
}
temp$logmsg <- paste(temp$logmsg, "No remaining neighbors.",
"This area cannot be merged further.")
} else {
# rank centroid distances ####
townvars$nborder <- rankGATdistance(area = area,
nbdata = townvars$nbdata,
first = temp$first,
gatvars = gatvars,
mergevars = mergevars)
# data which will be combined to form new region ####
townvars$newreg <- rbind(temp$first,
townvars$nbdata[townvars$nborder[1], ])
# add leading zeroes based on maximum number of areas
temp$zero <- paste(rep("0", temp$digits -
nchar(aggvars$newregno + maxid)),
collapse = "")
townvars$nrid <- paste0("GATid_", temp$zero,
as.character(aggvars$newregno + maxid))
temp$IDloc <- which(aggvars$IDlist %in% townvars$newreg[, gatvars$myidvar])
aggvars$IDlist[temp$IDloc] <- townvars$nrid
# calculate new region ####
townvars$newregdata <- createGATregion(mydata = aggvars$allpolydata,
newreg = townvars$newreg,
myidvar = gatvars$myidvar,
nrid = townvars$nrid,
area = area, pop = mapvars$pop,
IDlist = aggvars$IDlist,
pwrepeat = pwrepeat,
popwt = gatvars$popwt)
# add the new region to the list of data about the regions ####
aggvars$allpolydata <- rbind(aggvars$allpolydata, townvars$newregdata)
# need to remove the info about the old regions
aggvars$allpolydata <-
aggvars$allpolydata[which(!aggvars$allpolydata[, gatvars$myidvar] %in%
townvars$newreg[, gatvars$myidvar]), ]
# use spdep::aggregate.nb to create new object listing neighbors of aggregate
townvars$townnb <- spdep::aggregate.nb(townvars$oldtownnb, aggvars$IDlist)
aggvars$newregno <- aggvars$newregno + 1
}
# find the minimum population ####
temp$minpop1 <- min(aggvars$allpolydata[which(aggvars$allpolydata$GATflag == 0),
gatvars$aggregator1])
temp$minpop2 <- min(aggvars$allpolydata[which(aggvars$allpolydata$GATflag == 0),
gatvars$aggregator2])
if (temp$logmsg != "") {
aggvars$logmsg <- paste0(aggvars$logmsg, temp$logmsg, "\n")
}
}
# if function is isolated, close progress bar that monitors the aggregation
close(tmb)
return(aggvars)
}
gatvars <- list(
myidvar = "ID",             # character variable of unique values
aggregator1 = "TOTAL_POP",  # numeric variable
aggregator2 = "TOTAL_POP",  # numeric variable
minvalue1 = 10000, minvalue2 = 10000,
maxvalue1 = 40000, maxvalue2 = 40000,
boundary = "COUNTY",        # character variable of non-unique values
rigidbound = FALSE,          # boolean to enforce boundary
popwt = FALSE,              # boolean for population weighting
popvar = "Pop_tot"          # aggregation variable in population laayer
)
mergevars <- list(
mergeopt1 = "similar",    # string can be similar, closest, or least
similar1 = "B_TOT",       # numeric variable
similar2 = "W_TOT",        # numeric variable without any zeros
centroid = "geographic"
)
filevars <- list(
popfile = "hfblock",
poppath = paste0(find.package("gatpkg"), "/extdata")
)
my_merge <-
defineGATmerge(
area = hftown,
gatvars = gatvars,
mergevars = mergevars,
filevars = filevars, adjacent = TRUE,
pwrepeat = FALSE # don't need pwrepeat if popwt = FALSE
)
my_merge
devtools::check()
devtools::build()
install.packages("P:/Sections/EHS/Abigail/SubcountyData/Rcode/gatpkg_1.42.tar.gz", repos = NULL, type = "source")
gatpkg::runGATprogram()
