aggregator2 = "TOTAL_POP",  # numeric variable
minvalue1 = 5000, minvalue2 = 5000,
maxvalue1 = 15000, maxvalue2 = 15000,
boundary = "COUNTY",        # character variable of non-unique values
mergeopt1 = "closest",      # method used to merge polygons
rigidbound = FALSE,         # boolean: were boundaries enforced?,
savekml = FALSE,
popwt = FALSE
)
mergevars <- list(
mergeopt1 = "closest",    # can be similar, closest, or least
similar1 = "B_TOT",       # numeric variable
similar2 = "W_TOT",       # numeric variable without any zeros
centroid = "population-weighted"
)
ratevars <- list(
ratename = "pop_density",
numerator = "TOTAL_POP",
denominator = "AREALAND",
multiplier = 5000,
colorname = "Blue-Green",
colorscheme = "BuGn"
)
aggvars <- defineGATmerge(
area = hftown,
gatvars = gatvars,
mergevars = mergevars
)
filevars <- list(
filein = "hftown",                        # original filename
userin = paste0(getwd(), "/hftown"),      # original file and path name
userout = paste0(getwd(), "/my_hftown"),  # save file path and name
pathout = getwd(),                        # save path name
fileout = "my_hftown"                     # save file name
)
mysettings <- list(
starttime = Sys.time(),
version = "1.0",
pkgdate = format(Sys.Date(), "%m-%d-%Y"),
exists = TRUE
)
exclist <-
list(
var1 = "exclusion1",
var2 = "exclusion2",
var3 = "NONE",           # flag to denote no third variable
math1 = "greater than",
math2 = "less than",
math3 = "equals",
val1 = 5000,
val2 = 50,
val3 = 0,
flagsum = 5
)
writeGATlog(
area = hftown,
gatvars = gatvars,
filevars = filevars,
aggvars = aggvars,
mysettings = mysettings,
mergevars = mergevars,
ratevars = ratevars,
exclist = exclist
)
# if you run this example, it saves "my_hftown.log" to your working
# directory
gatvars <- list(
myidvar = "ID",             # character variable of unique values
aggregator1 = "TOTAL_POP",  # numeric variable
aggregator2 = "TOTAL_POP",  # numeric variable
minvalue1 = 5000, minvalue2 = 5000,
maxvalue1 = 15000, maxvalue2 = 15000,
boundary = "COUNTY",        # character variable of non-unique values
mergeopt1 = "closest",      # method used to merge polygons
rigidbound = FALSE,         # boolean: were boundaries enforced?,
savekml = FALSE,
popwt = FALSE
)
mergevars <- list(
mergeopt1 = "closest",    # can be similar, closest, or least
similar1 = "B_TOT",       # numeric variable
similar2 = "W_TOT",       # numeric variable without any zeros
centroid = "population-weighted"
)
ratevars <- list(
ratename = "pop_density",
numerator = "TOTAL_POP",
denominator = "AREALAND",
multiplier = 5000,
colorname = "Blue-Green",
colorscheme = "BuGn"
)
aggvars <- defineGATmerge(
area = hftown,
gatvars = gatvars,
mergevars = mergevars
)
filevars <- list(
filein = "hftown",                        # original filename
userin = paste0(getwd(), "/hftown"),      # original file and path name
userout = paste0(getwd(), "/my_hftown"),  # save file path and name
pathout = getwd(),                        # save path name
fileout = "my_hftown"                     # save file name
)
mysettings <- list(
starttime = Sys.time(),
version = "1.0",
pkgdate = format(Sys.Date(), "%m-%d-%Y"),
exists = TRUE
)
exclist <-
list(
var1 = "exclusion1",
var2 = "exclusion2",
var3 = "NONE",           # flag to denote no third variable
math1 = "greater than",
math2 = "less than",
math3 = "equals",
val1 = 5000,
val2 = 50,
val3 = 0,
flagsum = 5
)
writeGATlog(
area = hftown,
gatvars = gatvars,
filevars = filevars,
aggvars = aggvars,
mysettings = mysettings,
mergevars = mergevars,
ratevars = ratevars,
exclist = exclist
)
devtools::check()
devtools::check()
devtools::check()
devtools::build()
install.packages("P:/Sections/EHS/Abigail/SubcountyData/Rcode/gatpkg_1.42.tar.gz", repos = NULL, type = "source")
browseVignettes("gatpkg")
gatpkg::runGATprogram()
inputGATvariable <- function(title = "GAT window",
instruction = "Please select one.",
checkopt = "Select this checkbox.",
valueopt = "Enter a number:",
help = "There is no help for you.",
mylist = letters, checkbox = FALSE,
helppage = NULL, step = 0,
valuebox = FALSE, helptitle = NULL,
value = 0, myvar = "NONE", check = FALSE,
backopt = TRUE) {
tt <- tcltk::tktoplevel()
tcltk::tktitle(tt) <- paste0("Step ", step, ": ", title)
# create frames ####
# for some reason, within functions frames must all be created at the start
tt$frm <- tcltk::tkframe(tt, width = 300, height = 5)
tt$bound <- tcltk::tkframe(tt$frm, width = 150, height = 110)
tt$tfbuts <- tcltk::tkframe(tt$frm, width = 300, height = 40)
# list of options ####
tt$bound$note <- tcltk2::tk2label(tt$bound, text = instruction)
tt$bound$tl <- tcltk2::tk2listbox(tt$bound, height = 5,
values = mylist, selectmode = "single",
background = "white", value = myvar)
tcltk::tkgrid(tt$bound$note, sticky = "w", columnspan = 4, padx = 5)
tcltk::tkgrid(tt$bound$tl, padx = 10, pady = c(5, 10), sticky = "w",
row = 2, column = 1)
# checkbox and valuebox ####
if (checkbox | valuebox) {
tt$opts <- tcltk::tkframe(tt$frm, width = 150, height = 110)
if (checkbox) {
statebut <- if (check) "active" else "normal"
tt$bound$cb <- tcltk::tkcheckbutton(tt$opts)
tt$bound$cblabel <- tcltk2::tk2label(tt$opts, text = checkopt)
tt$bound$cbvalue <- tcltk::tclVar("0")
tcltk::tkconfigure(tt$bound$cb, variable = tt$bound$cbvalue, state = statebut)
tcltk::tkconfigure(tt$bound$cblabel, width = 20)
tcltk::tkgrid(tt$bound$cb, column = 1, row = 2, sticky = "n")
tcltk::tkgrid(tt$bound$cblabel, column = 2, row = 2, sticky = "nw")
}
if (valuebox) {
vbvalue <- tcltk::tclVar(value)
tt$bound$vb <- tcltk::tkentry(tt$opts, textvariable = vbvalue)
tt$bound$vblabel <- tcltk2::tk2label(tt$opts, text = valueopt)
tcltk::tkconfigure(tt$bound$vblabel, width = 25)
tcltk::tkgrid(tt$bound$vblabel, column = 1, columnspan = 2, sticky = "nw")
tcltk::tkgrid(tt$bound$vb, column = 1, columnspan = 2, sticky = "n")
}
}
# bottom button functions ####
myenv <- new.env()
if (checkbox & valuebox) {
onOk <- function() {
ind <- as.numeric(tcltk::tkcurselection(tt$bound$tl))
myvar <- mylist[ind + 1] # list 1
cbVal <- as.character(tcltk::tclvalue(tt$bound$cbvalue))
threshold <- as.character(tcltk::tclvalue(vbvalue))
tcltk::tkdestroy(tt)
if (cbVal == "1") check <- TRUE else check = FALSE
assign("myoptions", list(myvar = myvar,
check = check,
threshold = threshold), envir=myenv)
}
} else if (checkbox) {
onOk <- function() {
ind <- as.numeric(tcltk::tkcurselection(tt$bound$tl))
myvar <- mylist[ind + 1] # list 1
cbVal <- as.character(tcltk::tclvalue(tt$bound$cbvalue))
tcltk::tkdestroy(tt)
if (cbVal == "1") {
check <- TRUE
} else {
check = FALSE
}
assign("myoptions", list(myvar = myvar,
check = check,
threshold = 0), envir=myenv)
}
} else if (valuebox) {
onOk <- function() {
ind <- as.numeric(tcltk::tkcurselection(tt$bound$tl))
myvar <- mylist[ind + 1] # list 1
threshold <- as.character(tcltk::tclvalue(vbvalue))
tcltk::tkdestroy(tt)
assign("myoptions", list(myvar = myvar,
check = FALSE,
threshold = threshold), envir=myenv)
}
} else {
onOk <- function() {
ind <- as.numeric(tcltk::tkcurselection(tt$bound$tl))
myvar <- mylist[ind + 1] # list 1
tcltk::tkdestroy(tt)
assign("myoptions", list(myvar = myvar,
check = FALSE,
threshold = 0), envir=myenv)
}
} # OnOk function versions
onCancel <- function() {
tcltk::tkdestroy(tt)
assign("myoptions", list(myvar = "cancel",
check = FALSE,
threshold = 0), envir=myenv)
}
onHelp <- function() {
showGAThelp(help = help, helptitle = helppage,
helppage = helppage, helpimg = helppage, step = step)
}
onBack <- function() {
tcltk::tkdestroy(tt)
assign("myoptions", list(myvar = "back",
check = FALSE,
threshold = 0), envir=myenv)
}
# bottom button placements ####
if (backopt) {
tt$tfbuts$BackBut <- tcltk2::tk2button(tt$tfbuts, text = "< Back",
command = onBack, width = 12)
tt$tfbuts$OkBut <- tcltk2::tk2button(tt$tfbuts, text = "Next >",
command = onOk, width = 12,
default = "active")
} else {
tt$tfbuts$OkBut <- tcltk2::tk2button(tt$tfbuts, text = "Confirm",
command = onOk, width = 12,
default = "active")
}
tt$tfbuts$CancelBut <- tcltk2::tk2button(tt$tfbuts, text = "Cancel GAT",
command = onCancel, width = 12)
tt$tfbuts$HelpBut <- tcltk2::tk2button(tt$tfbuts, text = "Help",
command = onHelp, width = 12)
# add elements to the window
if (backopt) {
tcltk::tkgrid(tt$tfbuts$BackBut, column = 1, row = 1, pady = 5, padx = c(5, 0))
}
tcltk::tkgrid(tt$tfbuts$OkBut, column = 2, row = 1, pady = 5)
tcltk::tkgrid(tt$tfbuts$CancelBut, column = 3, row = 1, pady = 5)
tcltk::tkgrid(tt$tfbuts$HelpBut, column = 4, row = 1, pady = 5, padx = c(0, 5))
# configure elements ####
if (backopt) {
tcltk::tkgrid.configure(tt$tfbuts$BackBut, sticky = "e")
}
tcltk::tkgrid.configure(tt$tfbuts$OkBut, sticky = "w")
tcltk::tkpack(tt$tfbuts, tt$bound, side = "bottom")
if (checkbox | valuebox) {
tcltk::tkpack(tt$bound, tt$opts, side = "left", fill = "y")
}
tcltk::tkpack(tt$frm)
# wait for user ####
tcltk::tkfocus(tt)
tcltk::tkwait.window(tt) # pauses code to accept user input
return(myenv$myoptions)
}
?gatpkg::inputGATvariable
inputGATvariable(
title = "My favorite letter",
instruction = "Please select your favorite letter.",
help = "hlp",
mylist = letters,
checkopt = "Check this box \nif you love all letters.",
valueopt = "Enter the number of letters \nyou love.",
checkbox = TRUE,
valuebox = TRUE,
helppage = "inputGATvariable",
value = "5,000"
)
inputGATvariable(
title = "My favorite letter",
instruction = "Please select your favorite letter.",
help = "hlp",
mylist = letters,
checkopt = "Check this box \nif you love all letters.",
valueopt = "Enter the number of letters \nyou love.",
checkbox = TRUE,
valuebox = TRUE,
helppage = "inputGATvariable",
value = "5,000", backopt = FALSE
)
?gatpkg::identifyGATid
identifyGATid(
mapdata = hfpop@data
)
gatpkg::identifyGATid(
mapdata = hfpop@data
)
library(gatpkg)
identifyGATid(
mapdata = hfpop@data
)
gatpkg::identifyGATid(
mapdata = letters
)
gatpkg::identifyGATid(
mapdata = data.frame(letters)
)
gatpkg::identifyGATid(
mapdata = data.frame(ID = letters)
)
inputGATvariable(
title = "My favorite letter",
instruction = "Please select your favorite letter.",
help = "hlp",
mylist = letters,
checkopt = "Check this box \nif you love all letters.",
valueopt = "Enter the number of letters \nyou love.",
checkbox = TRUE,
valuebox = TRUE,
helppage = "inputGATvariable",
value = "5,000", backopt = FALSE
)
inputGATvariable(
title = "My favorite letter",
instruction = "Please select your favorite letter.",
help = "hlp",
mylist = letters,
checkopt = "Check this box \nif you love all letters.",
valueopt = "Enter the number of letters \nyou love.",
checkbox = TRUE,
valuebox = TRUE,
helppage = "inputGATvariable",
value = "5,000", backopt = FALSE
)
inputGATvariable(
title = "My favorite letter",
instruction = "Please select your favorite letter.",
help = "hlp",
mylist = letters,
checkopt = "Check this box \nif you love all letters.",
valueopt = "Enter the number of letters \nyou love.",
checkbox = TRUE,
valuebox = TRUE,
helppage = "inputGATvariable",
value = "5,000", backopt = FALSE
)
devtools::check()
devtools::check()
devtools::check()
devtools::build()
remove.packages("gatpkg", lib="~/R/win-library/3.6")
install.packages("P:/Sections/EHS/Abigail/SubcountyData/Rcode/gatpkg_1.43.tar.gz", repos = NULL, type = "source")
browseVignettes("gatpkg")
browseVignettes("gatpkg")
library(gatpkg)
inputGATaggregators(
mapdata = hftown@data
)
inputGATaggregators(    mapdata = hftown@data, backopt = FALSE)
inputGATexclusions(
mapdata = hftown@data,
step = 10
)
inputGATexclusions(
mapdata = hftown@data,
step = 10, backopt = FALSE
)
inputGATmerge(
mapdata = hftown@data,
aggvar = "TOTAL_POP",
aggvar2 = "W_TOT"
)
inputGATmerge(
mapdata = hftown@data,
aggvar = "TOTAL_POP",
aggvar2 = "W_TOT", backopt = FALSE
)
inputGATmessage(
title = "Random message window"
)
inputGATmessage(
title = "Random message window", backopt = FALSE
)
inputGATrate(
mapdata = hftown@data,
help = "hlp",
limitdenom = FALSE
)
inputGATrate(
mapdata = hftown@data,
help = "hlp",
limitdenom = FALSE, backopt = FALSE
)
inputGATvalue(
title = "Learning your name",
help = "hlp",
message = "Please enter your name.",
defaulttext = "Charlie Brown"
)
inputGATvalue(
title = "Learning your name",
help = "hlp",
message = "Please enter your name.",
defaulttext = "Charlie Brown", backopt = FALSE
)
inputGATvariable(
title = "My favorite letter",
instruction = "Please select your favorite letter.",
help =" hlp",
mylist = letters,
checkopt = "Check this box \nif you love all letters.",
valueopt = "Enter the number of letters \nyou love.",
checkbox = TRUE,
valuebox = TRUE,
helppage = "inputGATvariable",
value = "5,000"
)
inputGATvariable(
title = "My favorite letter",
instruction = "Please select your favorite letter.",
help =" hlp",
mylist = letters,
checkopt = "Check this box \nif you love all letters.",
valueopt = "Enter the number of letters \nyou love.",
checkbox = TRUE,
valuebox = TRUE,
helppage = "inputGATvariable",
value = "5,000", backopt = FALSE
)
gatvars <-
list(
aggregator1 = "agg1",
aggregator2 = "agg2",
myidvar = "tract",
minvalue1 = 5000,
minvalue2 = 10000,
maxvalue1 = 10000,
maxvalue2 = 15000,
boundary = "county",
rigidbound = FALSE,
popvar = "total_pop",
savekml = TRUE,
numrow = 15
)
mergevars <-
list(
mergeopt1 = "similar", # can be similar, closest, or least
similar1 = "ratio1",
similar2 = "ratio2",
centroid = "geographic"
)
ratevars <-
list(
ratename = "my_rate",
numerator = "case",
denominator = "pop",
multiplier = 100000
)
exclist <-
list(
var1 = "exclusion1",
var2 = "exclusion2",
var3 = "NONE", # flag to denote no third variable
math1 = "greater than",
math2 = "less than",
math3 = "equals",
val1 = 10000,
val2 = 50,
val3 = 0,
flagsum = 5
)
filevars <-
list(
filein = "hftown",
popfile = "hfblock",
fileout = "my_savefile",
userin = "C:/users/default/shapefiles/hftown",
userout = "C:/users/default/shapefiles/my_saves/my_savefile"
)
confirmGATbystep(
gatvars = gatvars,
ratevars = ratevars,
mergevars = mergevars,
exclist = exclist,
filevars = filevars,
step = 10
)
