}
} else {
# "else" occurs only if GAT is cancelled in the input phase
# there are now redundant warnings; function-level are commented out
msg <- "You have chosen to cancel GAT."
tcltk::tkmessageBox(title = "GAT cancelled",
message = msg,
type = "ok", icon = "warning")
}
# end GAT ####
close(tpb)
}
defineGATmerge_minfirst <- function(area, gatvars, mergevars, filevars,
pwrepeat = FALSE,
adjacent = TRUE, minfirst = FALSE) {
# temp until it's programmed in ####
if (!"GATflag" %in% names(area@data)) {
area@data$GATflag <- 0 # for non-default uses of this function
}
if (gatvars$aggregator2 == "NONE") {
gatvars$aggregator2 <- gatvars$aggregator1
}
max1 <- as.numeric(gsub(",", "", gatvars$maxvalue1))
min1 <- as.numeric(gsub(",", "", gatvars$minvalue1))
max2 <- as.numeric(gsub(",", "", gatvars$maxvalue2))
min2 <- as.numeric(gsub(",", "", gatvars$minvalue2))
# draw progress bar ####
mb <- list(label = "Preparing merge files. Please wait.",
title = "NYSDOH GAT: merging")
tmb <- tcltk::tkProgressBar(title = mb$title, label = mb$label, min = 0,
max = nrow(area@data), initial = 0, width = 400)
# if projection is lat/lon, projection = TRUE, otherwise FALSE
mapvars <- list(projection = grepl("longlat",
sp::proj4string(area), fixed = TRUE))
# set up centroids ####
# find a way to not hit memory limit for population weighting
if (gatvars$popwt) {
# may need to assign ID as row names
mb$label = "Loading population file. This step may be slow."
tcltk::setTkProgressBar(tmb, value = 0, title = mb$title,
label = mb$label)
temp <- weightGATmap(area = area, popvar = gatvars$popvar,
filevars = filevars, idvar = gatvars$myidvar)
mapvars$centroids <- temp$centroids
mapvars$pop <- temp$pop
# area@data$GATpop <- mapvars$centroids$GATpop
} else {
mapvars$centroids <- sp::coordinates(area)
colnames(mapvars$centroids) <- c("GATx", "GATy")
mapvars$pop <- NULL
}
# default to not lat/long if something goes wrong
if (is.na(mapvars$projection)) mapvars$projection <- FALSE
# add centroids to polygon data ####
aggvars <- list(IDlist = as.character(area@data[, gatvars$myidvar]),
allpolydata = data.frame(area@data, mapvars$centroids),
newregno = 1,
logmsg = "") # record merge warnings in the log)
# set up temporary variables ####
if (gatvars$aggregator2 == "NONE") gatvars$aggregator2 <- gatvars$aggregator1
# for some reason, numeric sometimes switched to character
aggvars$allpolydata[, gatvars$aggregator1] <-
as.numeric(as.character(aggvars$allpolydata[, gatvars$aggregator1]))
aggvars$allpolydata[, gatvars$aggregator2] <-
as.numeric(as.character(aggvars$allpolydata[, gatvars$aggregator2]))
temp <- list(alldata = aggvars$allpolydata[which(aggvars$allpolydata$GATflag == 0), ],
digits = nchar(nrow(aggvars$allpolydata)),
index = sapply(aggvars$allpolydata, is.integer),
rownames = area@data[, gatvars$myidvar])
# test if loop can be run ####
if (nrow(temp$alldata) > 0) {
# set up more temporary variables ####
temp$minpop1 = min(temp$alldata[, gatvars$aggregator1])
temp$minpop2 = min(temp$alldata[, gatvars$aggregator2])
myids <- as.character(unlist(data.frame(area@data[, gatvars$myidvar])))
myids <- myids[grepl("GATid", myids)]
myids <- gsub("GATid_", "",  myids)
if (length(myids) == 0) {
maxid <- 0
} else {
maxid <- max(as.numeric(myids))
temp$digits <- nchar(myids[1])
}
# set up town variables ####
# get list of neighbors using poly2nb method from spdep packagetow
townvars <- list(oldtownnb = spdep::poly2nb(area, queen = FALSE,
row.names = temp$rownames),
townnb = spdep::poly2nb(area, queen = FALSE,
row.names = temp$rownames))
# convert integers to double (change to convert when I read in file?)
# might be redundant now, but check later
aggvars$allpolydata[, temp$index] <-
sapply(aggvars$allpolydata[, temp$index], as.numeric)
# start while loop ####
while ((temp$minpop1 < gatvars$minvalue1) |
(temp$minpop2 < gatvars$minvalue2)){
# identify who is mergable ####
# remove flagged areas
temp$aggdata <-
aggvars$allpolydata[which(aggvars$allpolydata$GATflag == 0), ]
# isolate areas that are too small
temp$tobemerged <- temp$aggdata[which(
(temp$aggdata[, gatvars$aggregator1] < min1) |
(temp$aggdata[, gatvars$aggregator2] < min2) ), ]
# change the merge order high to low
if (temp$minpop1 < min1) {
temp$tobemerged <-
temp$tobemerged[order(-temp$tobemerged[, gatvars$aggregator1]), ]
} else {
temp$tobemerged <-
temp$tobemerged[order(-temp$tobemerged[, gatvars$aggregator2]), ]
}
# default merge option is the one selected
mergevars$mergeopt2 <- mergevars$mergeopt1
# incremental progress bar ####
mb$label <- paste0("Merge ", aggvars$newregno + maxid, ": ",
nrow(temp$tobemerged), " areas remaining.")
step <- nrow(area@data) - nrow(temp$tobemerged)
tcltk::setTkProgressBar(tmb, value = step, title = mb$title,
label = mb$label)
# identify the area to merge this loop ####
temp$first <- identifyGATfirstobs(tobemerged = temp$tobemerged,
aggvar = gatvars$aggregator1,
aggvar2 = gatvars$aggregator2,
minval = gatvars$minvalue1,
minval2 = gatvars$minvalue2)
# remove areas that are too large
temp$aggdata <- temp$aggdata[which(
(temp$aggdata[, gatvars$aggregator1] +
temp$first[, gatvars$aggregator1] < max1) |
(temp$aggdata[, gatvars$aggregator2] +
temp$first[, gatvars$aggregator2] < max2)), ]
# set up warnings ####
temp$logmsg <- paste0("Merge ", aggvars$newregno + maxid, " (",
temp$first[, gatvars$myidvar], "):")
temp$warnkey <- "n" # no warnings
warnings <- c(
ab = "No physically adjacent neighbors found within the same boundary.",
amb = "No physically adjacent neighbors below the minimum value found within the same boundary.",
mb = "Found areas in the same boundary below the minimum value, but they are not physically adjacent.",
b = "Found areas in the same boundary, but they are not physically adjacent.",
f = "No neighbors found. This area cannot be merged further.",
nb = "No neighbors found in boundary.",
am = "No physically adjacent neighbors found below the minimum aggregation value."
)
# find neighbors ####
# temporary flag: neighbors found?
temp$idfail <- TRUE
townvars$townnbid <- attr(townvars$townnb, "region.id")
if (temp$first[, gatvars$myidvar] %in% townvars$townnbid) {
townvars$townnbidloc <- which(townvars$townnbid ==
temp$first[, gatvars$myidvar])
townvars$neighbors <- townvars$townnb[[townvars$townnbidloc]]
townvars$neighborid <- townvars$townnbid[townvars$neighbors]
townvars$nbdata <-
temp$aggdata[which(temp$aggdata[, gatvars$myidvar] %in%
townvars$neighborid), ]
}
# get the data about these neighbors ####
# if boundary variable
if (gatvars$boundary != "NONE") {
temp$firstboundary <- as.character(temp$first[, gatvars$boundary])
# index of neighbors in same county
temp$inboundary <- townvars$nbdata[which(
townvars$nbdata[, gatvars$boundary] == temp$firstboundary), ]
# find neighbors in boundary, adjacent, below minimum value
if (minfirst) {
townvars$nbdata <-
temp$inboundary[which(temp$inboundary[, gatvars$aggregator1] < min1 |
temp$inboundary[, gatvars$aggregator2] < min2), ]
temp$inco_dex <- which(townvars$nbdata[, gatvars$boundary] ==
temp$firstboundary)
temp$inco_nbdata <- townvars$nbdata[temp$inco_dex, ]
if (nrow(temp$inco_nbdata) > 0) {
townvars$nbdata <- temp$inco_nbdata
temp$idfail <- FALSE
} else {
temp$warnkey <- "amb" # no adjacent below min within boundary
temp$idfail <- TRUE
}
}
# if no neighbors, find neighbors in boundary, adjacent
if (temp$idfail) {
townvars$nbdata <-
temp$inboundary[which(temp$inboundary[, gatvars$myidvar] %in%
townvars$neighborid), ]
# index of neighbors in same county
temp$inco_dex <- which(townvars$nbdata[, gatvars$boundary] ==
temp$firstboundary)
temp$inco_nbdata <- townvars$nbdata[temp$inco_dex, ]
if (nrow(temp$inco_nbdata) > 0) {
townvars$nbdata <- temp$inco_nbdata
temp$idfail <- FALSE # found neighbor
} else {
temp$warnkey <- "ab" # no adjacent within boundary
temp$idfail <- TRUE # still failed
}
}
# if no neighbors, find other area in boundary
if (!adjacent & temp$idfail) {
# below minimum preferred?
if (minfirst) {
temp$inco_nbdata <-
temp$tobemerged[which(temp$tobemerged[, gatvars$boundary] ==
temp$firstboundary &
temp$tobemerged[, gatvars$myidvar] !=
temp$first[, gatvars$myidvar]), ]
if(nrow(temp$inco_nbdata) > 0) {
townvars$nbdata <- temp$inco_nbdata
mergevars$mergeopt2 <- "closest"
temp$warnkey <- "mb"
temp$idfail <- FALSE
} else {
temp$idfail <- TRUE
}
}
# if still failing
if (temp$idfail) {
temp$inco_nbdata <-
temp$aggdata[which(temp$aggdata[, gatvars$boundary] ==
temp$firstboundary &
temp$aggdata[, gatvars$myidvar] !=
temp$first[, gatvars$myidvar]), ]
if(nrow(temp$inco_nbdata) > 0){
townvars$nbdata <- temp$inco_nbdata
mergevars$mergeopt2 <- "closest"
temp$warnkey <- "b"
temp$idfail <- FALSE
} else {
temp$idfail <- TRUE
}
}
}
if (temp$idfail) {
temp$warnkey <- "nb"
}
}
# if no boundary or none in boundary (and boundary not enforced)
if (minfirst & temp$idfail & !gatvars$rigidbound) {
# reset town list, just in case
townvars$nbdata <-
temp$tobemerged[which(temp$tobemerged[, gatvars$myidvar] %in%
townvars$neighborid), ]
if (nrow(townvars$nbdata) > 0) {
temp$idfail <- FALSE # found neighbor
} else {
temp$warnkey <- "am" # no adjacent below minimum
temp$idfail <- TRUE # still failed
}
}
# if no boundary or minimum enforcement (or none available)
if (!adjacent & temp$idfail & !gatvars$rigidbound) {
# reset town list, just in case
townvars$nbdata <-
townvars$nbdata[which(temp$aggdata[, gatvars$myidvar] %in%
townvars$neighborid), ]
if (nrow(townvars$nbdata) > 0) {
temp$idfail <- FALSE # found neighbor
} else {
if (temp$logmsg == "") {
temp$logmsg <- paste0(temp$logmsg, "Merge ", aggvars$newregno + maxid,
" (", temp$first[, gatvars$myidvar], "):")
}
temp$logmsg <- paste(temp$logmsg,
"No physically adjacent neighbors found.")
temp$idfail <- TRUE # still failed
}
if (temp$idfail) {
mergevars$mergeopt2 <- "closest"
townvars$townnbidloc <- which(townvars$townnbid ==
temp$first[, gatvars$myidvar])
townvars$neighbors <- townvars$townnb[[townvars$townnbidloc]]
townvars$neighborid <- townvars$townnbid[townvars$neighbors]
townvars$nbdata <-
temp$aggdata[which(temp$aggdata[, gatvars$myidvar] %in%
townvars$neighborid), ]
if (nrow(townvars$nbdata) > 0) {
temp$idfail <- FALSE # found neighbor
} else {
temp$idfail <- TRUE # still failed
}
}
}
# quit searching for neighbors ####
if(temp$idfail) {
# check for and remove flags and oversized at beginning of loop
aggvars$allpolydata$GATflag[aggvars$allpolydata[, gatvars$myidvar] ==
temp$first[, gatvars$myidvar]] <- 10
temp$warnkey <- "f"
} else {
# rank centroid distances ####
townvars$nborder <- rankGATdistance(area = area,
nbdata = townvars$nbdata,
first = temp$first,
gatvars = gatvars,
mergevars = mergevars)
# data which will be combined to form new region ####
townvars$newreg <- rbind(temp$first,
townvars$nbdata[townvars$nborder[1], ])
# add leading zeroes based on maximum number of areas
temp$zero <- paste(rep("0", temp$digits -
nchar(aggvars$newregno + maxid)),
collapse = "")
townvars$nrid <- paste0("GATid_", temp$zero,
as.character(aggvars$newregno + maxid))
temp$IDloc <- which(aggvars$IDlist %in% townvars$newreg[, gatvars$myidvar])
aggvars$IDlist[temp$IDloc] <- townvars$nrid
# calculate new region ####
townvars$newregdata <- createGATregion(mydata = aggvars$allpolydata,
newreg = townvars$newreg,
myidvar = gatvars$myidvar,
nrid = townvars$nrid,
area = area, pop = mapvars$pop,
IDlist = aggvars$IDlist,
pwrepeat = pwrepeat,
popwt = gatvars$popwt)
# add the new region to the list of data about the regions ####
aggvars$allpolydata <- rbind(aggvars$allpolydata, townvars$newregdata)
# need to remove the info about the old regions
aggvars$allpolydata <-
aggvars$allpolydata[which(!aggvars$allpolydata[, gatvars$myidvar] %in%
townvars$newreg[, gatvars$myidvar]), ]
# use spdep::aggregate.nb to create new object listing neighbors of aggregate
townvars$townnb <- spdep::aggregate.nb(townvars$oldtownnb, aggvars$IDlist)
aggvars$newregno <- aggvars$newregno + 1
}
# find the minimum population ####
temp$minpop1 <- min(aggvars$allpolydata[which(aggvars$allpolydata$GATflag == 0),
gatvars$aggregator1])
temp$minpop2 <- min(aggvars$allpolydata[which(aggvars$allpolydata$GATflag == 0),
gatvars$aggregator2])
if (temp$warnkey != "n") {
aggvars$logmsg <- paste(aggvars$logmsg, temp$logmsg,
warnings[temp$warnkey], "\n")
}
# 'garbage collection': free up memory ####
gc(verbose = FALSE)
}
} else {
if (gatvars$aggregator1 == gatvars$aggregator2) {
vars <- gatvars$aggregator1
} else {
vars <- paste(gatvars$aggregator1, "and", gatvars$aggregator2)
}
msg <- paste("All areas have values of", vars,
"over your selected minimum value(s). No areas were merged.")
tcltk::tkmessageBox(title = "Merge failed", message = msg,
type = "yesno", icon = "info")
}
# if function is isolated, close progress bar that monitors the aggregation
close(tmb)
return(aggvars)
}
path <- "P:/Sections/EHS/Abigail/SubcountyData/Rcode/GATtest/testdata/tract_mcd/"
set <- "gat_step2_newmcdsettings.Rdata"
runGATprogram_testmin(settings = paste0(path, "/", set), minfirst = TRUE)
path <- "P:/Sections/EHS/Arjita/EPHT/Sub-County/Creating new Agg Areas/with GAT147"
set <- "PWC_Gat_step2settings.Rdata"
runGATprogram_testmin(settings = paste0(path, "/", set), minfirst = TRUE)
devtools::check()
browseVignettes("gatpkg")
browseVignettes(gatpkg)
gatpkg::inputGATmergepop(mapdata = gatpkg::hftown@data, aggvar = "TOTAL_POP", aggvar2 = "NONE")
# code to generate window for inputGATmergepop.png
gatpkg::inputGATmerge(mapdata = gatpkg::hftown@data, aggvar = "TOTAL_POP", aggvar2 = "NONE")
# code to generate window for inputGATrate.png
gatpkg::inputGATrate(mapdata = gatpkg::hftown@data, limitdenom = FALSE)
# code to generate window for saveGATkml.png
gatpkg::saveGATkml()
devtools::build()
remove.packages("gatpkg", lib="~/R/win-library/3.6")
install.packages("P:/Sections/EHS/Abigail/SubcountyData/Rcode/gatpkg_1.49.tar.gz", repos = NULL, type = "source")
browseVignettes("gatpkg")
gatpkg::runGATprogram()
gatpkg::runGATprogram(minfirst = TRUE, settings = "P:/Sections/EHS/Abigail/SubcountyData/Rcode/GATtest/testdata/abby/hh_nominfirstsettings.Rdata")
library(gatpkg)
path <- "P:/Sections/EHS/Abigail/SubcountyData/Rcode/GATtest/testdata/abby"
set1 <- "hh_minfirstsettings.Rdata"
set2 <- "hh_nominfirstsettings.Rdata"
runGATprogram(settings = paste0(path, "/", set1), minfirst = TRUE)
runGATprogram(settings = paste0(path, "/", set2), minfirst = FALSE)
path <- "P:/Sections/EHS/Abigail/SubcountyData/Rcode/GATtest/testdata/abby"
set1 <- "hh_minfirstsettings.Rdata"
set2 <- "hh_nominfirstsettings.Rdata"
runGATprogram(settings = paste0(path, "/", set1), minfirst = TRUE)
runGATprogram(settings = paste0(path, "/", set2), minfirst = FALSE)
devtools::check()
devtools::build()
??BWidget
vignette("gat_tech_notes", package = "gatpkg")
vignette("tech_notes", package = "gatpkg")
browseVignettes("gatpkg")
vignette("gat_tutorial", package = "gatpkg")
remove.packages("gatpkg", lib="~/R/win-library/3.6")
install.packages("P:/Sections/EHS/Abigail/SubcountyData/Rcode/gatpkg_1.50.tar.gz", repos = NULL, type = "source")
browseVignettes("gatpkg")
vignette("gat_tech_notes", package = "gatpkg")
browseVignettes("gatpkg")
knitr::include_graphics("images/locateGATshapefile.png")
knitr::include_graphics("images/saveGATkml.png")
# fix this image and pre-select options
browseVignettes("gatpkg")
library(gatpkg)
?confirmGATbystep
gatvars <-
list(
aggregator1 = "agg1",
aggregator2 = "agg2",
myidvar = "tract",
minvalue1 = 5000,
minvalue2 = 10000,
maxvalue1 = 10000,
maxvalue2 = 15000,
boundary = "county",
rigidbound = FALSE,
popvar = "total_pop",
savekml = TRUE,
numrow = 15,
exclmaxval = 2
)
mergevars <-
list(
mergeopt1 = "similar", # can be similar, closest, or least
similar1 = "ratio1",
similar2 = "ratio2",
centroid = "geographic"
)
ratevars <-
list(
ratename = "my_rate",
numerator = "case",
denominator = "pop",
multiplier = 100000,
colorname = "Blue-Green"
)
exclist <-
list(
var1 = "exclusion1",
var2 = "exclusion2",
var3 = "NONE", # flag to denote no third variable
math1 = "greater than",
math2 = "less than",
math3 = "equals",
val1 = 10000,
val2 = 50,
val3 = 0,
flagsum = 5
)
filevars <-
list(
filein = "hftown",
popfile = "hfblock",
fileout = "my_savefile",
userin = "C:/users/default/shapefiles/hftown",
userout = "C:/users/default/shapefiles/my_saves/my_savefile"
)
confirmGATbystep(
gatvars = gatvars,
ratevars = ratevars,
mergevars = mergevars,
exclist = exclist,
filevars = filevars,
step = 10
)
# code to generate window for locateGATshapefile.png
gatvars <- list(aggregator1 = "TOTAL_POP", aggregator2 = "TOTAL_POP",
myidvar = "ID", minvalue1 = 5000, minvalue2 = 5000,
boundary = "COUNTY", rigidbound = TRUE, popvar = "Pop_tot",
savekml = FALSE)
mergevars <- list(mergeopt1 = "closest", similar1 = "AREALAND",
similar2 = "AREALAND", centroid = "population-weighted")
ratevars <- list(ratename = "pop_dens", numerator = "TOTAL_POP",
denominator = "AREALAND", multiplier = 10000,
colorname = "Greens")
exclist <- list(var1 = "B_TOT", var2 = "NONE", var3 = "NONE",
math1 = "equals", math2 = "equals", math3 = "equals",
val1 = 0, val2 = 0, val3 = 0, flagsum = 6)
filevars <- list(filein = "hftown", popfile = "hfblock",
fileout = "hftownagg5kbypopwt")
gatpkg::confirmGATbystep(gatvars = gatvars, ratevars = ratevars,
mergevars = mergevars, exclist = exclist,
filevars = filevars, savekml = FALSE, step = 11)
# code to generate window for locateGATshapefile.png
gatvars <- list(aggregator1 = "TOTAL_POP", aggregator2 = "TOTAL_POP",
myidvar = "ID", minvalue1 = 5000, minvalue2 = 5000,
boundary = "COUNTY", rigidbound = TRUE, popvar = "Pop_tot",
savekml = FALSE)
mergevars <- list(mergeopt1 = "closest", similar1 = "AREALAND",
similar2 = "AREALAND", centroid = "population-weighted")
ratevars <- list(ratename = "pop_dens", numerator = "TOTAL_POP",
denominator = "AREALAND", multiplier = 10000,
colorname = "Greens")
exclist <- list(var1 = "B_TOT", var2 = "NONE", var3 = "NONE",
math1 = "equals", math2 = "equals", math3 = "equals",
val1 = 0, val2 = 0, val3 = 0, flagsum = 6)
filevars <- list(filein = "hftown", popfile = "hfpop",
fileout = "hftown_agg5k15k_popwt",
userin = "C:/users/default/shapefiles/hftown",
userout = "C:/users/default/shapefiles/my_saves/hftown_agg5k15k_popwt")
gatpkg::confirmGATbystep(gatvars = gatvars, ratevars = ratevars,
mergevars = mergevars, exclist = exclist,
filevars = filevars, savekml = FALSE, step = 11)
confirmGATquit()
?confirmGATquit()
pathin <- paste0(find.package("gatpkg"), "/extdata")
mywtshp <- importGATweights(shp = hftown, filein = "hfblock", pathin)
pathin <- paste0(find.package("gatpkg"), "/extdata")
mywtshp <- importGATweights(area = hftown, filein = "hfpop", pathin)
pathin
pathin <- paste0(find.package("gatpkg"), "/extdata")
mywtshp <- importGATweights(area = hftown, filein = "hfblock", pathin)
?runGATprogram
