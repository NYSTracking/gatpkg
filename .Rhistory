# pre-load number function
numformat <- function(num) {
format(as.numeric(gsub(",", "", num)), big.mark=",", scientific=FALSE)
}
while (step == 1) { # ask user to identify shapefile; check its usability
pb <- list(title = "NYSDOH GAT: identify shapefile",
label = "Identifying and selecting the shapefile.")
tcltk::setTkProgressBar(tpb, value = step, title = pb$title,
label = pb$label)
# identify shapefile
filevars <- locateGATshapefile(myfile = filevars$userin, step = step)
if (filevars$userin == "cancel") {
step <- 20
mysettings$quit <- TRUE
} else {
# read in map data only from the shapefile's dbf
temp$mapdata <- foreign::read.dbf(paste0(filevars$userin, ".dbf"),
as.is = TRUE)
temp$shp <- rgdal::readOGR(dsn = filevars$pathin,
layer = filevars$filein,
stringsAsFactors = FALSE)
# check for both numeric and character data
temp$numerics <- checkGATvariabletypes(temp$mapdata, type = "number")
temp$alphas <- checkGATvariabletypes(temp$mapdata, type = "character")
temp$polys <- class(temp$shp)
# add dialog specifying each issue
# add check for shapefile type (if class(shp) )
temp$msg <- ""
temp$error <- FALSE
if (nrow(temp$shp@data) < 2) {
temp$issue <- "at least 2 areas."
temp$error <- TRUE
} else if (temp$polys != "SpatialPolygonsDataFrame") {
# message: wrong kind of shapefile; repeat dialog
temp$issue <- "polygons."
temp$error <- TRUE
} else if (length(temp$numerics) == 0) {
# message: there are no numeric variables; repeat dialog
temp$issue <- "any numeric variables."
temp$error <- TRUE
} else if (length(temp$alphas) == 0) {
# message: there are no character variables; repeat dialog
temp$issue <- "any non-numeric variables."
temp$error <- TRUE
} else {
temp$old_vars <- c()
for (i in 1:ncol(temp$mapdata)) {
# possibly these can be removed entirely, but need to verify
# if removing, inform user with warning dialog
# not sure how to handle flag variable - rename it?
if (names(temp$mapdata)[i] %in%
c("old_GATx", "old_GATy", "old_GATnumIDs", "old_GATcratio",
"old_flag", "old_GATpop")) {
temp$old_vars <- c(temp$old_vars, names(temp$mapdata)[i])
}
}
if (length(temp$old_vars) > 0) {
temp$msg <- paste(temp$msg,
paste(temp$old_vars, collapse = ", "),
"were removed from the data frame.")
}
temp$mapdata <- temp$mapdata[,
names(temp$mapdata)[!names(temp$mapdata) %in% temp$old_vars]]
for (i in 1:ncol(temp$mapdata)) {
if (names(temp$mapdata)[i] %in%
c("GATx", "GATy", "GATnumIDs", "GATcratio", "GATflag", "GATpop")) {
temp$msg <- paste(temp$msg,
"\n", names(temp$mapdata)[i], "has been changed to",
paste0("old_", names(temp$mapdata)[i], "."))
names(temp$mapdata)[i] <- paste0("old_", names(temp$mapdata)[i])
}
}
if (temp$msg != "") {
tcltk::tkmessageBox(title = "Some variable names changed", type = "ok",
icon = "warning", message = temp$msg)
}
step <- step + 1
}
if (temp$error) {
temp$msg <- paste("The shapefile", filevars$filein,
"does not contain", temp$issue, "\n",
"Please select a new shapefile.")
tcltk::tkmessageBox(title = "Shapefile invalid", type = "ok",
icon = "error", message = temp$msg)
temp$error <- FALSE
}
}
} # end request shapefile (userin)
while (step == 2) { # ask user to select ID variable that uniquely
# identifies areas to be merged
pb <- list(title = "NYSDOH GAT: identify identifier",
label = "Selecting the unique identifier.")
tcltk::setTkProgressBar(tpb, value = step, title = pb$title,
label = pb$label)
# identify GAT polygon identifier variable
gatvars$myidvar <- identifyGATid(mapdata = temp$mapdata, step = step,
backopt = !temp$flagconfirm)
if (gatvars$myidvar == "back"){
step <- step - 1
} else if (gatvars$myidvar == "cancel") {
mysettings$quit <- TRUE
step <- 20
} else if (gatvars$myidvar == "missing") {
temp$msg <- paste("The shapefile does not contain a suitable ID variable.",
"A temporary ID will be created.")
tcltk::tkmessageBox(title = "No suitable ID variable", message = temp$msg,
type = "ok", icon = "warning")
} else { # go ahead
if (temp$flagconfirm) {
step <- 11
} else {
step <- step + 1
}
}
} # end request id variable (myidvar)
while (step == 3) { #ask user to select boundary variable, if present
pb <- list(title = "NYSDOH GAT: identify boundary",
label = "Selecting the boundary variable.")
tcltk::setTkProgressBar(tpb, value = step, title = pb$title,
label = pb$label)
if (is.null(gatvars$boundary)) {
gatvars$boundary <- "NONE"
gatvars$rigidbound <- FALSE
}
tempbound <- NULL
while (is.null(tempbound)) {
tempbound <- identifyGATboundary(data = temp$mapdata, step = step,
boundary = gatvars$boundary,
borders = gatvars$rigidbound,
backopt = !temp$flagconfirm)
}
gatvars$rigidbound <- tempbound$check
gatvars$boundary <- tempbound$myvar
if (gatvars$boundary == "NONE") {
gatvars$rigidbound <- FALSE # just in case user selects both
}
if (gatvars$boundary == "back") {
step <- step - 1
} else if (gatvars$boundary == "cancel") {
mysettings$quit <- TRUE
step <- 20
} else {
if (temp$flagconfirm) {
step <- 11
} else {
step <- step + 1
}
}
rm(tempbound)
} # end request boundary variable (boundaryvar)
while (step == 4) { # ask for aggregation variables
pb <- list(title = "NYSDOH GAT: identify aggregators",
label = "Selecting the aggregation variables.")
tcltk::setTkProgressBar(tpb, value = step, title = pb$title,
label = pb$label)
if (is.null(gatvars$aggregator1)) {
agglist <- NULL
} else {
agglist <- list(var1 = gatvars$aggregator1,
var2 = gatvars$aggregator2,
minval1 = gatvars$minvalue1,
maxval1 = gatvars$maxvalue1,
minval2 = gatvars$minvalue2,
maxval2 = gatvars$maxvalue2)
}
error <- TRUE
# re-call the function as needed
while (error) {
agglist <- identifyGATaggregators(mapdata = temp$mapdata,
step = step,
agglist = agglist,
backopt = !temp$flagconfirm)
error <- FALSE
if (is.null(agglist)) {
x <- confirmGATquit()
if (x == "quit") {
agglist <- list(var1 = "cancel")
} else {
error <- TRUE
agglist <- list(var1 = "")
}
} else if (length(agglist$var1) == 0) {
error <- TRUE
agglist <- NULL
}
}
if (agglist$var1 == "back") {
step <- step - 1
} else if (agglist$var1 == "cancel") {
step <- 20
mysettings$quit <- TRUE
} else if (!error) {
gatvars$aggregator1 <- agglist$var1
gatvars$aggregator2 <- agglist$var2
gatvars$minvalue1 <- agglist$minval1
gatvars$maxvalue1 <- agglist$maxval1
gatvars$minvalue2 <- agglist$minval2
gatvars$maxvalue2 <- agglist$maxval2
if (temp$flagconfirm) {
step <- 11
} else {
step <- step + 1
}
}
rm(agglist)
} # end request aggregation variables (agglist)
while (step == 5) {
pb <- list(title = "NYSDOH GAT: Enter exclusions",
label = "Identifying your exclusion criteria.")
tcltk::setTkProgressBar(tpb, value = step, title = pb$title,
label = pb$label)
if (!exists("exclist")) exclist <- NULL
temp$error <- TRUE
while (temp$error) {
exclist <- inputGATexclusions(mapdata = temp$mapdata, step = step,
exclist = exclist,
backopt = !temp$flagconfirm)
temp$error <- FALSE
if (is.null(exclist)) {
x <- confirmGATquit()
if (x == "quit") {
exclist <- list(var1 = "cancel")
} else {
temp$error <- TRUE
exclist <- list(var1 = "")
}
}
# get rid of all non-numeric characters
# move this to a function?
if (!temp$error & !exclist$var1 %in% c("back", "cancel")) {
if (exclist$math1 == "less than") {
temp$minmaxlbl <- "maximum"
} else if (exclist$math1 == "greater than") {
temp$minmaxlbl <- "minimum"
} else {
temp$minmaxlbl <- ""
}
while (grepl("[^0-9.,-]", exclist$val1)) {
gats <- list(title = paste("Threshold for", exclist$var1),
msg = paste("Please enter a valid", temp$minmaxlbl, "number for",
exclist$var1),
help = paste0("To continue, enter a valid number and click 'Next >',",
"\nto return to exclusion selection, click '< Back',",
"\nand to quit the program, click 'Cancel'."))
exclist$val1 <- inputGATvalue(title = gats$title, help = gats$help,
message = gats$msg, defaulttext = "1,000",
helppage = "inputGATvalue", step = step,
backopt = !temp$flagconfirm)
if (exclist$val1 == "back") {
exclist$var1 <- "back"
exclist$val1 <- 0
} else if (exclist$val1 == "cancel") {
exclist$var1 <- "cancel"
exclist$val1 <- 0
mysettings$quit <- TRUE
step <- 20
}
}
while (grepl("[^0-9.,-]", exclist$val2)) {
if (exclist$math2 == "less than") {
temp$minmaxlbl <- "maximum"
} else if (exclist$math2 == "greater than") {
temp$minmaxlbl <- "minimum"
} else {
temp$minmaxlbl <- ""
}
gats <- list(title = paste("Threshold for", exclist$var2),
msg = paste("Please enter a valid", temp$minmaxlbl, "number for",
exclist$var2),
help = paste0("To continue, enter a valid number and click 'Next >',",
"\nto return to exclusion selection, click '< Back',",
"\nand to quit the program, click 'Cancel'."))
exclist$val2 <- inputGATvalue(title = gats$title, help = gats$help,
message = gats$msg, defaulttext = "1,000",
helppage = "inputGATvalue", step = step,
backopt = !temp$flagconfirm)
if (exclist$val2 == "back") {
exclist$var1 <- "back"
exclist$val2 <- 0
} else if (exclist$val2 == "cancel") {
exclist$var1 <- "cancel"
exclist$val2 <- 0
mysettings$quit <- TRUE
step <- 20
}
}
while (grepl("[^0-9.,-]", exclist$val3)) {
if (exclist$math3 == "less than") {
temp$minmaxlbl <- "maximum"
} else if (exclist$math3 == "greater than") {
temp$minmaxlbl <- "minimum"
} else {
temp$minmaxlbl <- ""
}
gats <- list(title = paste("Threshold for", exclist$var3),
msg = paste("Please enter a valid", temp$minmaxlbl, "number for",
exclist$var3),
help = paste0("To continue, enter a valid number and click 'Next >',",
"\nto return to exclusion selection, click '< Back',",
"\nand to quit the program, click 'Cancel'."))
exclist$val3 <- inputGATvalue(title = gats$title, help = gats$help,
message = gats$msg, defaulttext = "1,000",
helppage = "inputGATvalue", step = step,
backopt = !temp$flagconfirm)
if (exclist$val3 == "back") {
exclist$var1 <- "back"
exclist$val3 <- 0
} else if (exclist$val3 == "cancel") {
exclist$var1 <- "cancel"
exclist$val3 <- 0
mysettings$quit <- TRUE
step <- 20
}
}
exclist$val1 <- as.numeric(gsub(",", "", exclist$val1))
exclist$val2 <- as.numeric(gsub(",", "", exclist$val2))
exclist$val3 <- as.numeric(gsub(",", "", exclist$val3))
} else if (exclist$var1 == "back") {
step <- step - 1
} else if (exclist$var1 == "cancel") {
mysettings$quit <- TRUE
step <- 20
}
}
# calculate exclusions now to use them to calculate the
# denominator for similar merges and rates
temp$mapdata$GATflag <- 0
temp$mapdata$GATflag <- calculateGATflag(exclist, temp$mapdata)
exclist$flagsum <- sum(temp$mapdata$GATflag != 0)
if (nrow(temp$mapdata) - exclist$flagsum < 2) {
temp$msg <- paste("This selection will exclude", exclist$flagsum,
"of", nrow(temp$mapdata), "areas.", "\n",
"GAT requires at least 2 areas to run.", "\n",
"Please select new exclusion criteria.")
tcltk::tkmessageBox(title = "Selections invalid", type = "ok",
icon = "error", message = temp$msg)
temp$error <- TRUE
} else if (exclist$flagsum > 0) {
temp$msg <- "You have selected to exclude:"
i <- list(var = c(exclist$var1, exclist$var2, exclist$var3),
math = c(exclist$math1, exclist$math2, exclist$math3),
val = c(exclist$val1, exclist$val2, exclist$val3))
for (j in 1:3) {
if (i$var[j] != "NONE") {
temp$msg <- paste(temp$msg, "\n   ", i$var[j], i$math[j], i$val[j])
}
}
temp$msg <- paste(temp$msg, "\nThis will exclude", exclist$flagsum,
"of", nrow(temp$mapdata), "areas.")
temp$help <- paste0("To continue, select 'Yes',",
"\nto reselect exclusion criteria, select 'Repeat',",
"\nand to return to second aggregation variable selection,",
"click '< Back',")
temp$cancel <- inputGATmessage(title = "Excluded areas", help = temp$help,
helptitle = "inputGATmessage",
helppage = "inputGATmessage", step = 6,
msg = temp$msg, buttonopt = "Repeat")
if (temp$cancel == "cancel") {
exclist$var1 <- "repeat"
} else if (temp$cancel == "back") {
exclist$var1 <- "back"
step <- step - 1
}
}
if (!exclist$var1 %in% c("back", "cancel") & !temp$error) {
if (temp$flagconfirm) {
step <- 11
} else {
step <- step + 1
}
}
} # end request exclusions (exclist)
exclist
temp$error <- TRUE
while (temp$error) {
exclist <- inputGATexclusions(mapdata = temp$mapdata, step = step,
exclist = exclist,
backopt = !temp$flagconfirm)
temp$error <- FALSE
if (is.null(exclist)) {
x <- confirmGATquit()
if (x == "quit") {
exclist <- list(var1 = "cancel")
} else {
temp$error <- TRUE
exclist <- list(var1 = "")
}
}
# get rid of all non-numeric characters
# move this to a function?
if (!temp$error & !exclist$var1 %in% c("back", "cancel")) {
if (exclist$math1 == "less than") {
temp$minmaxlbl <- "maximum"
} else if (exclist$math1 == "greater than") {
temp$minmaxlbl <- "minimum"
} else {
temp$minmaxlbl <- ""
}
while (grepl("[^0-9.,-]", exclist$val1)) {
gats <- list(title = paste("Threshold for", exclist$var1),
msg = paste("Please enter a valid", temp$minmaxlbl, "number for",
exclist$var1),
help = paste0("To continue, enter a valid number and click 'Next >',",
"\nto return to exclusion selection, click '< Back',",
"\nand to quit the program, click 'Cancel'."))
exclist$val1 <- inputGATvalue(title = gats$title, help = gats$help,
message = gats$msg, defaulttext = "1,000",
helppage = "inputGATvalue", step = step,
backopt = !temp$flagconfirm)
if (exclist$val1 == "back") {
exclist$var1 <- "back"
exclist$val1 <- 0
} else if (exclist$val1 == "cancel") {
exclist$var1 <- "cancel"
exclist$val1 <- 0
mysettings$quit <- TRUE
step <- 20
}
}
while (grepl("[^0-9.,-]", exclist$val2)) {
if (exclist$math2 == "less than") {
temp$minmaxlbl <- "maximum"
} else if (exclist$math2 == "greater than") {
temp$minmaxlbl <- "minimum"
} else {
temp$minmaxlbl <- ""
}
gats <- list(title = paste("Threshold for", exclist$var2),
msg = paste("Please enter a valid", temp$minmaxlbl, "number for",
exclist$var2),
help = paste0("To continue, enter a valid number and click 'Next >',",
"\nto return to exclusion selection, click '< Back',",
"\nand to quit the program, click 'Cancel'."))
exclist$val2 <- inputGATvalue(title = gats$title, help = gats$help,
message = gats$msg, defaulttext = "1,000",
helppage = "inputGATvalue", step = step,
backopt = !temp$flagconfirm)
if (exclist$val2 == "back") {
exclist$var1 <- "back"
exclist$val2 <- 0
} else if (exclist$val2 == "cancel") {
exclist$var1 <- "cancel"
exclist$val2 <- 0
mysettings$quit <- TRUE
step <- 20
}
}
while (grepl("[^0-9.,-]", exclist$val3)) {
if (exclist$math3 == "less than") {
temp$minmaxlbl <- "maximum"
} else if (exclist$math3 == "greater than") {
temp$minmaxlbl <- "minimum"
} else {
temp$minmaxlbl <- ""
}
gats <- list(title = paste("Threshold for", exclist$var3),
msg = paste("Please enter a valid", temp$minmaxlbl, "number for",
exclist$var3),
help = paste0("To continue, enter a valid number and click 'Next >',",
"\nto return to exclusion selection, click '< Back',",
"\nand to quit the program, click 'Cancel'."))
exclist$val3 <- inputGATvalue(title = gats$title, help = gats$help,
message = gats$msg, defaulttext = "1,000",
helppage = "inputGATvalue", step = step,
backopt = !temp$flagconfirm)
if (exclist$val3 == "back") {
exclist$var1 <- "back"
exclist$val3 <- 0
} else if (exclist$val3 == "cancel") {
exclist$var1 <- "cancel"
exclist$val3 <- 0
mysettings$quit <- TRUE
step <- 20
}
}
exclist$val1 <- as.numeric(gsub(",", "", exclist$val1))
exclist$val2 <- as.numeric(gsub(",", "", exclist$val2))
exclist$val3 <- as.numeric(gsub(",", "", exclist$val3))
} else if (exclist$var1 == "back") {
step <- step - 1
} else if (exclist$var1 == "cancel") {
mysettings$quit <- TRUE
step <- 20
}
}
temp$mapdata$GATflag <- 0
temp$mapdata$GATflag <- calculateGATflag(exclist, temp$mapdata)
head(temp$mapdata)
exclist
d <- temp$mapdata
if (exclist$var1 != "NONE") {
d <- calculateGATexclusions(d, exclist$var1, exclist$math1, exclist$val1)
}
if (exclist$var2 != "NONE") {
d <- calculateGATexclusions(d, exclist$var2, exclist$math2, exclist$val2)
}
if (exclist$var2 != "NONE") {
d <- calculateGATexclusions(d, exclist$var3, exclist$math3, exclist$val3)
}
if (exclist$var3 != "NONE") {
d <- calculateGATexclusions(d, exclist$var3, exclist$math3, exclist$val3)
}
devtools::check()
devtools::build()
install.packages("P:/Sections/EHS/Abigail/SubcountyData/Rcode/gatpkg_1.44.tar.gz", repos = NULL, type = "source")
library(gatpkg)
runGATprogram()
runGATprogram()
browseVignettes("gatpkg")
?gatpkg
library(gatpkg)
?gatpkg
