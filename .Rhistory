tt$tftexts$vartext2 <- tcltk::tclVar(ratevars$ratename)
tt$tftexts$multtext <- tcltk::tkentry(tt$tftexts, width = "20",
textvariable = tt$tftexts$vartext1)
tt$tftexts$nametext <- tcltk::tkentry(tt$tftexts, width = "20",
textvariable = tt$tftexts$vartext2)
tcltk::tkgrid(tt$tftexts$namelabel, sticky = "w", padx = 5, column = 1,
row = 8, rowspan = 2, columnspan = 1) # could also use pady = 5
tcltk::tkgrid(tt$tftexts$multlabel, sticky = "w", padx = 5, column = 3,
row = 8, rowspan = 2, columnspan = 1)
tcltk::tkgrid(tt$tftexts$nametext, column = 1, row = 10, padx = 5,
sticky = "w") # text entry box
tcltk::tkgrid(tt$tftexts$perlabel, column = 2, row = 10)
tcltk::tkgrid(tt$tftexts$multtext, column = 3, row = 10, padx = 5, pady = 5,
columnspan = 2, sticky = "w") # text entry box
tcltk::tkselection.from(tt$tftexts$multtext, "0")
tcltk::tkfocus(tt$tftexts$multtext)
myenv <- new.env()
######### code for buttons #########
onOk <- function() {
multiplier <- tcltk::tclvalue(tt$tftexts$vartext1)
ratename <- tcltk::tclvalue(tt$tftexts$vartext2)
ind <- as.numeric(tcltk::tkcurselection(tt$tflists$tnum))
numerator <- gatlist1[ind + 1] # list 1
ind <- as.numeric(tcltk::tkcurselection(tt$tflists$tden))
denominator <- gatlist2[ind + 1] # list 2
ind <- as.numeric(tcltk::tkcurselection(tt$tflists$tcol))
colorscheme <- colors[ind + 1] # list 3
cbVal <- as.character(tcltk::tclvalue(tt$tfcheck$cbvalue))
tcltk::tkdestroy(tt)
if (cbVal == "1") {
ratename <- "no_rate"
}
# keep all alphabetical characters
ratename <- gsub("([^a-z|A-Z|_])", "", ratename)
# set default if user gives invalid name
if (ratename == "" | is.na(ratename)) ratename <- "gat_rate"
assign("reslist", list(ratename = ratename,
numerator = numerator,
denominator = denominator,
multiplier = multiplier,
colorscheme = colorscheme), envir=myenv)
}
onCancel <- function() {
tcltk::tkdestroy(tt)
assign("reslist", list(ratename = "cancel",
numerator = "NONE",
denominator = "NONE",
multiplier = "0",
colorscheme = "NONE"), envir=myenv)
}
onBack <- function() {
tcltk::tkdestroy(tt)
assign("reslist", list(ratename = "back",
numerator = "NONE",
denominator = "NONE",
multiplier = "0",
colorscheme = "NONE"), envir=myenv)
}
onHelp <- function() {
showGAThelp(help = hlp, helptitle = "rate settings",
helppage = helppage, step = step)
}
if (backopt) {
tt$tfbuts$BackBut <- tcltk2::tk2button(tt$tfbuts, text = "< Back",
command = onBack, width = 12)
tt$tfbuts$OkBut <- tcltk2::tk2button(tt$tfbuts, text = "Next >",
command = onOk, width = 12,
default = "active")
} else {
tt$tfbuts$OkBut <- tcltk2::tk2button(tt$tfbuts, text = "Confirm",
command = onOk, width = 12,
default = "active")
}
tt$tfbuts$CancelBut <- tcltk2::tk2button(tt$tfbuts, text = "Cancel GAT",
command = onCancel, width = 12)
tt$tfbuts$HelpBut <- tcltk2::tk2button(tt$tfbuts, text = "Help",
command = onHelp, width = 12)
# add elements to the window
if (backopt) {
tcltk::tkgrid(tt$tfbuts$BackBut, column = 1, row = 11, padx = 5,
pady = 5, padx = c(5, 0))
}
tcltk::tkgrid(tt$tfbuts$OkBut, column = 2, row = 11, padx = 5, pady = 5)
tcltk::tkgrid(tt$tfbuts$CancelBut, column = 3, row = 11, padx = 5, pady = 5)
tcltk::tkgrid(tt$tfbuts$HelpBut, column = 4, row = 11, padx = 5,
pady = 5, padx = c(0, 5))
# configure elements
if (backopt) {
tcltk::tkgrid.configure(tt$tfbuts$BackBut, sticky = "e")
}
tcltk::tkgrid.configure(tt$tfbuts$OkBut, sticky = "w")
######### end program ########
tcltk::tkwait.window(tt)
if (identical(myenv$reslist$colorscheme, character(0))) {
myenv$reslist$colorscheme <- "BuGn"
}
myenv$reslist$colorname <- colorlist[colors == myenv$reslist$colorscheme]
return(myenv$reslist) # ratevars values
} # end gatrateInput function
ratevars <- inputGATrate(mapdata = temp$mapflag,
limitdenom = limitdenom,
step = step,
ratevars = ratevars,
backopt = !temp$flagconfirm)
ratevars
browseVignettes("gatpkg")
?gatpkg
?gatpkg::gatpkg
?rep
library(tidyverse)
path <- "P:/Sections/EHS/Abigail/SubcountyData/Shapefiles"
s <- rgdal::readOGR(path, "ny_counties_length")
#### calculate compactness ####
sp::proj4string(s)
mapcenter <- rgeos::gCentroid(s, byid = FALSE) # get center of map
latcenter <- mapcenter@coords[1]
# myutm <- floor((-75.5+180)/6)+1
myutm <- floor((latcenter + 180) / 6) + 1
pstring <- paste0("+proj=utm +zone=", myutm,
"+datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0")
s <- sp::spTransform(s, sp::CRS(pstring))
rm(mapcenter, latcenter, myutm, pstring)
calculateGATcompactness <- function(map) {
# start calculate compactness ratio
myareas <- rgeos::gArea(map, byid = TRUE)
myhulls <- rgeos::gConvexHull(map, byid = TRUE)
hullcoords <- lapply(myhulls@polygons, function(y) {
y@Polygons[[1]]@coords
} )
hulldists <- lapply(hullcoords, dist)
diams <- sapply(hulldists, max)
# calculate compactness ratio
# to get maximum distance (diameter of circle): max(dist(test1))
cratio <- myareas / (pi * ((diams / 2) ** 2))
map@data <- cbind(map@data, diams, cratio)
return(cratio)
}
rm(calculateGATcompactness())
rm(calculateGATcompactness
)
calculate_compactness <- function(map) {
# start calculate compactness ratio
myareas <- rgeos::gArea(map, byid = TRUE)
myhulls <- rgeos::gConvexHull(map, byid = TRUE)
hullcoords <- lapply(myhulls@polygons, function(y) {
y@Polygons[[1]]@coords
} )
hulldists <- lapply(hullcoords, dist)
diams <- sapply(hulldists, max)
# calculate compactness ratio
# to get maximum distance (diameter of circle): max(dist(test1))
cratio <- myareas / (pi * ((diams / 2) ** 2))
map@data <- cbind(map@data, diams, cratio)
return(cratio)
}
d <- calculate_compactness(s)
head(d)
head(s@data)
sp::plot(map)
sp::plot(s)
library(tidyverse)
path <- "M:/ARCGIS/Demographics/Census/TIGER/2016"
s <- rgdal::readOGR(path, "tl_2016_36_countyL")
sp::plot(s)
s <- rgdal::readOGR(path, "tl_2016_36_county")
sp::plot(s)
calculate_compactness <- function(map) {
# start calculate compactness ratio
myareas <- rgeos::gArea(map, byid = TRUE)
myhulls <- rgeos::gConvexHull(map, byid = TRUE)
hullcoords <- lapply(myhulls@polygons, function(y) {
y@Polygons[[1]]@coords
} )
hulldists <- lapply(hullcoords, dist)
diams <- sapply(hulldists, max)
# calculate compactness ratio
# to get maximum distance (diameter of circle): max(dist(test1))
cratio <- myareas / (pi * ((diams / 2) ** 2))
d <- cbind(map@data, diams, cratio)
return(d)
}
d <- calculate_compactness(s)
head(d)
sp:proj(s)
sp::proj(s)
sp::proj4string(s)
calculate_compactness <- function(shp) {
proj <- grepl("longlat", sp::proj4string(shp), fixed = TRUE)
if (!proj | is.na(proj)) {
# if not lat/lon, can use directly to calculate compactness ratio
map <- shp
} else if (proj) { # find approx longitude of map
mapcenter <- rgeos::gCentroid(shp, byid = FALSE) # get center of map
latcenter <- mapcenter@coords[1]
myutm <- floor((latcenter + 180) / 6) + 1
pstring <- paste0("+proj=utm +zone=", myutm,
"+datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0")
map <- sp::spTransform(shp, sp::CRS(pstring))
} # if lat/long, need to reproject
myareas <- rgeos::gArea(map, byid = TRUE)
myhulls <- rgeos::gConvexHull(map, byid = TRUE)
hullcoords <- lapply(myhulls@polygons, function(y) {
y@Polygons[[1]]@coords
} )
hulldists <- lapply(hullcoords, dist)
diams <- sapply(hulldists, max)
# calculate compactness ratio
# to get maximum distance (diameter of circle): max(dist(test1))
cratio <- myareas / (pi * ((diams / 2) ** 2))
d <- cbind(map@data, diams, cratio)
return(d)
}
d <- calculate_compactness(s)
head(d)
d <- calculate_compactness(s) %>%
select(NAME, GEOID, diams, cratio) %>%
mutate(radius = diams / 2 * pi)
head(d)
d <- calculate_compactness(s) %>%
select(NAME, GEOID, diams, cratio) %>%
mutate(radius = diams / (2 * pi))
head(d)
s@data <- d
d$NAME[d$cratio = max(d$cratio)]
d$NAME[d$cratio == max(d$cratio)]
# max compactness = st lawrence
d$NAME[d$cratio == min(d$cratio)]
max <- d$NAME[d$cratio == max(d$cratio)]
# max compactness = st lawrence
min <- d$NAME[d$cratio == min(d$cratio)]
# min compactness = cayuga
cy <- subset(s, s@data$NAME == min)
sl <- subset(s, s@data$NAME == max)
sp::plot(cy)
sp::plot(sl)
sp::bbox(cy)
sp::bbox(cy)[1. 1]
sp::bbox(cy)[1, 1]
centroid_calc <- function(shp) {
bb <- sp::bbox(shp)
x <- sum(bb[1, ]) / 2
y <- sum(bb[2, ]) / 2
centroid <- c(x, y)
return(centroid)
}
cy_c <- centroid_calc(cy)
sl_c <- centroid_calc(sl)
plot(sl_c, add = TRUE)
sp::plot(sl_c, add = TRUE)
sp::plot(sl)
sp::plot(sl_c, add = TRUE)
points(sl_c)
points(sl_c[1], sl_c[2])
sp::plot(sl_c[1], sl_c[2])
sp::plot(sl)
sp::plot(sl_c[1], sl_c[2])
sp::plot(sl)
sp::plot(sl_c[1], sl_c[2], add=TRUE)
?sp::plot
sp::plot(cy)
sp::plot(sl)
sl_c
points(-75.19286,  44.53313)
points(sl_c[1], sl_c[2])
sl_c[1]
plotCircle <- function(x, y, r) {
angles <- seq(0,2*pi,length.out=360)
lines(r*cos(angles)+x,r*sin(angles)+y)
} # https://stackoverflow.com/questions/23071026/drawing-a-circle-with-a-radius-of-a-defined-distance-in-a-map
plotCircle(sl_c[1], sl_c[2], sl@data$radius)
angles <- seq(0, 2*pi, length.out = 360)
x = sl_c[1]
y = sl_c[2]
r = sl@data$radius
lines(r * cos(angles) + x, r * sin(angles) + y)
(r * cos(angles) + x
)
plotCircle <- function(LonDec, LatDec, Km) {#Corrected function
#LatDec = latitude in decimal degrees of the center of the circle
#LonDec = longitude in decimal degrees
#Km = radius of the circle in kilometers
ER <- 6371 #Mean Earth radius in kilometers. Change this to 3959 and you will have your function working in miles.
AngDeg <- seq(1:360) #angles in degrees
Lat1Rad <- LatDec*(pi/180)#Latitude of the center of the circle in radians
Lon1Rad <- LonDec*(pi/180)#Longitude of the center of the circle in radians
AngRad <- AngDeg*(pi/180)#angles in radians
Lat2Rad <-asin(sin(Lat1Rad)*cos(Km/ER)+cos(Lat1Rad)*sin(Km/ER)*cos(AngRad)) #Latitude of each point of the circle rearding to angle in radians
Lon2Rad <- Lon1Rad+atan2(sin(AngRad)*sin(Km/ER)*cos(Lat1Rad),cos(Km/ER)-sin(Lat1Rad)*sin(Lat2Rad))#Longitude of each point of the circle rearding to angle in radians
Lat2Deg <- Lat2Rad*(180/pi)#Latitude of each point of the circle rearding to angle in degrees (conversion of radians to degrees deg = rad*(180/pi) )
Lon2Deg <- Lon2Rad*(180/pi)#Longitude of each point of the circle rearding to angle in degrees (conversion of radians to degrees deg = rad*(180/pi) )
polygon(Lon2Deg,Lat2Deg,lty=2)
}
plotCircle(LonDec = sl_c[1], LatDec = sl_c[2], Km = sl@data$radius)
sp::plot(s)
plotCircle(LonDec = sl_c[1], LatDec = sl_c[2], Km = sl@data$radius)
plotCircle(LonDec = sl_c[1], LatDec = sl_c[2], Km = sl@data$radius/1000)
plotCircle(LonDec = sl_c[1], LatDec = sl_c[2], Km = sl@data$radius/100)
plotCircle(LonDec = sl_c[1], LatDec = sl_c[2], Km = sl@data$radius/10)
sp::proj4string(sl)
calculate_compactness <- function(shp) {
proj <- grepl("longlat", sp::proj4string(shp), fixed = TRUE)
if (!proj | is.na(proj)) {
# if not lat/lon, can use directly to calculate compactness ratio
map <- shp
} else if (proj) { # find approx longitude of map
mapcenter <- rgeos::gCentroid(shp, byid = FALSE) # get center of map
latcenter <- mapcenter@coords[1]
myutm <- floor((latcenter + 180) / 6) + 1
pstring <- paste0("+proj=utm +zone=", myutm,
"+datum=NAD83 +units=mi +no_defs +ellps=GRS80 +towgs84=0,0,0")
map <- sp::spTransform(shp, sp::CRS(pstring))
} # if lat/long, need to reproject
myareas <- rgeos::gArea(map, byid = TRUE)
myhulls <- rgeos::gConvexHull(map, byid = TRUE)
hullcoords <- lapply(myhulls@polygons, function(y) {
y@Polygons[[1]]@coords
} )
hulldists <- lapply(hullcoords, dist)
diams <- sapply(hulldists, max)
# calculate compactness ratio
# to get maximum distance (diameter of circle): max(dist(test1))
cratio <- myareas / (pi * ((diams / 2) ** 2))
d <- cbind(map@data, diams, cratio)
return(d)
}
d <- calculate_compactness(s) %>%
select(NAME, GEOID, diams, cratio) %>%
mutate(radius = diams / (2 * pi))
d <- calculate_compactness(s)
head(d)
library(tidyverse)
path <- "M:/ARCGIS/Demographics/Census/TIGER/2016"
s <- rgdal::readOGR(path, "tl_2016_36_county")
#### calculate compactness ####
calculate_compactness <- function(shp) {
proj <- grepl("longlat", sp::proj4string(shp), fixed = TRUE)
if (!proj | is.na(proj)) {
# if not lat/lon, can use directly to calculate compactness ratio
map <- shp
} else if (proj) { # find approx longitude of map
mapcenter <- rgeos::gCentroid(shp, byid = FALSE) # get center of map
latcenter <- mapcenter@coords[1]
myutm <- floor((latcenter + 180) / 6) + 1
pstring <- paste0("+proj=utm +zone=", myutm,
"+datum=NAD83 +units=mi +no_defs +ellps=GRS80 +towgs84=0,0,0")
map <- sp::spTransform(shp, sp::CRS(pstring))
} # if lat/long, need to reproject
myareas <- rgeos::gArea(map, byid = TRUE)
myhulls <- rgeos::gConvexHull(map, byid = TRUE)
hullcoords <- lapply(myhulls@polygons, function(y) {
y@Polygons[[1]]@coords
} )
hulldists <- lapply(hullcoords, dist)
diams <- sapply(hulldists, max)
# calculate compactness ratio
# to get maximum distance (diameter of circle): max(dist(test1))
cratio <- myareas / (pi * ((diams / 2) ** 2))
d <- cbind(map@data, diams, cratio)
return(d)
}
d <- calculate_compactness(s) %>%
select(NAME, GEOID, diams, cratio) %>%
mutate(radius = diams / (2 * pi))
head(d)
s@data <- d
max <- d$NAME[d$cratio == max(d$cratio)]
# max compactness = st lawrence
min <- d$NAME[d$cratio == min(d$cratio)]
# min compactness = cayuga
max;min
s@data <- d
cy <- subset(s, s@data$NAME == min)
sl <- subset(s, s@data$NAME == max)
centroid_calc <- function(shp) {
bb <- sp::bbox(shp)
x <- sum(bb[1, ]) / 2
y <- sum(bb[2, ]) / 2
centroid <- c(x, y)
return(centroid)
}
cy_c <- centroid_calc(cy)
sl_c <- centroid_calc(sl)
sp::plot(sl)
points(sl_c[1], sl_c[2])
plotCircle(LonDec = sl_c[1], LatDec = sl_c[2], Km = sl@data$radius*1.60934)
s <- rgdal::readOGR(path, "tl_2016_36_county")
#### calculate compactness ####
# calculates in miles
calculate_compactness <- function(shp) {
proj <- grepl("longlat", sp::proj4string(shp), fixed = TRUE)
if (!proj | is.na(proj)) {
# if not lat/lon, can use directly to calculate compactness ratio
map <- shp
} else if (proj) { # find approx longitude of map
mapcenter <- rgeos::gCentroid(shp, byid = FALSE) # get center of map
latcenter <- mapcenter@coords[1]
myutm <- floor((latcenter + 180) / 6) + 1
pstring <- paste0("+proj=utm +zone=", myutm,
"+datum=NAD83 +units=mi +no_defs +ellps=GRS80 +towgs84=0,0,0")
map <- sp::spTransform(shp, sp::CRS(pstring))
} # if lat/long, need to reproject
myareas <- rgeos::gArea(map, byid = TRUE)
myhulls <- rgeos::gConvexHull(map, byid = TRUE)
hullcoords <- lapply(myhulls@polygons, function(y) {
y@Polygons[[1]]@coords
} )
hulldists <- lapply(hullcoords, dist)
diams <- sapply(hulldists, max)
# calculate compactness ratio
# to get maximum distance (diameter of circle): max(dist(test1))
cratio <- myareas / (pi * ((diams / 2) ** 2))
d <- cbind(map@data, diams, cratio)
return(d)
}
d <- calculate_compactness(s) %>%
select(NAME, GEOID, diams, cratio) %>%
mutate(radius = diams / 2)
s@data <- d
cy <- subset(s, s@data$NAME == min)
sl <- subset(s, s@data$NAME == max)
centroid_calc <- function(shp) {
bb <- sp::bbox(shp)
x <- sum(bb[1, ]) / 2
y <- sum(bb[2, ]) / 2
centroid <- c(x, y)
return(centroid)
}
cy_c <- centroid_calc(cy)
sl_c <- centroid_calc(sl)
sp::plot(sl)
points(sl_c[1], sl_c[2])
plotCircle(LonDec = sl_c[1], LatDec = sl_c[2], Km = sl@data$radius*1.60934)
sp::plot(sl, col = "LightSeaGreen", border = "white")
plotCircle(LonDec = sl_c[1], LatDec = sl_c[2], Km = sl@data$radius*1.60934)
sp::plot(cy, col = "LightSeaGreen", border = "white")
plotCircle(LonDec = cy_c[1], LatDec = cy_c[2], Km = cy@data$radius*1.60934)
sl@data
cy@data
library(gatpkg)
?createGATregion
# create dataset with polygons to merge
ids <- c("e", "e", "d", "d", "f", "f", "f", "e", "e", "d", "e",
"d", "b", "c", "c", "a", "b", "c", "a", "b", "c")
my_merged_obs <-
createGATregion(
mydata = hftown@data,
newreg = hftown@data[ids=="a",],
myidvar = "ID",
nrid = "a",
area = hftown,
pop = hfpop,
IDlist = ids,
pwrepeat = TRUE,
popwt = TRUE
)
my_merged_obs
mydata = hftown@data
newreg = hftown@data[ids=="a",]
myidvar = "ID"
nrid = "a"
area = hftown
pop = hfpop
IDlist = ids
pwrepeat = TRUE
popwt = TRUE
listtype <- sapply(mydata, class)
listtypetf <- listtype %in% c("integer", "numeric")
listitems <- unique(names(mydata)) # to handle non-default use
newregchars <- newreg[2, !listtypetf]
newregchars
paste(newreg[, !listtypetf], sep = ", ")
paste(newreg[, !listtypetf], collapse = ", ")
sapply(newreg[, !listtypetf], paste(collapse = ", "))
sapply(newreg[, !listtypetf], paste)
tempvars <- newreg[, !listtypetf]
newregchars <- data.frame()
for (i in names(tempvars)) {
newregchars[, i] <- paste(tempvars[, i], collapse = ", ")
}
newregchars <- c()
for (i in 1:length(names(tempvars))) {
newregchars[i] <- paste(tempvars[, names(tempvars)[i]], collapse = ", ")
names(newregchars[i]) <- names(tempvars)[i]
}
newregchars
for (i in 1:length(names(tempvars))) {
newregchars[i] <- paste(tempvars[, names(tempvars)[i]], collapse = ", ")
names(newregchars)[i] <- names(tempvars)[i]
}
newregchars <- data.frame(newregchars)
tempvars <- newreg[, !listtypetf]
newregchars <- c()
for (i in 1:length(names(tempvars))) {
newregchars[i] <- paste(tempvars[, names(tempvars)[i]], collapse = ", ")
names(newregchars)[i] <- names(tempvars)[i]
}
newregchars
newregchars <- data.frame(t(newregchars))
newregchars <- c()
for (i in 1:length(names(tempvars))) {
newregchars[i] <- paste(tempvars[, names(tempvars)[i]], collapse = ", ")
names(newregchars)[i] <- names(tempvars)[i]
}
newregchars <- data.frame(matrix(newregchars, nrow = 1))
newregchars
names(newregchars) <- names(tempvars)
newregchars
unique(tempvars[, names(tempvars)[i]]
[order(tempvars[, names(tempvars)[i]])])
i = 1
unique(tempvars[, names(tempvars)[i]]
[order(tempvars[, names(tempvars)[i]])])
