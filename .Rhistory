} # end request population weighting
while (step == 8) { # step 9: get rate settings
pb <- list(title = "NYSDOH GAT: identify rate",
label = "Selecting the rate details.")
tcltk::setTkProgressBar(tpb, value = step, title = pb$title,
label = pb$label)
if (length(temp$numerics) > 1) {
error <- TRUE
if (!exists("ratevars")) ratevars <- list()
while (error) {
ratevars <- inputGATrate(mapdata = temp$mapflag,
limitdenom = limitdenom,
step = step, ratevars = ratevars)
error <- FALSE
# returns list(multiplier, ratename, numerator, denominator, colorscheme)
if (!exists("ratename", ratevars)) {
x <- confirmGATquit()
if (x == "quit") {
ratevars <- list(ratename = "cancel")
} else {
error <- TRUE
}
}
if (ratevars$ratename == "cancel") {
mysettings$quit <- TRUE
step <- 20
} else if (!ratevars$ratename == "no_rate" & !error) {
# quality control - force numeric
while (grepl("[^0-9.,-]", ratevars$multiplier)) {
gats <- list(title = paste("Multiplier for", ratevars$ratename),
msg = paste0("Please enter a valid number for the ",
"multiplier for ", ratevars$ratename, "."),
help = paste0("Enter a valid number. \n",
"  \u2022  To continue,  click 'Next >'. \n",
"  \u2022  To return to rate settings, click '< Back'.",
"  \u2022  To quit GAT, click 'Cancel'."))
ratevars$multiplier <- inputGATvalue(title = gats$title, help = gats$help,
message = gats$msg, defaulttext = "10,000",
helppage = "inputGATvalue", step = step)
if (ratevars$multiplier == "back") {
ratevars$ratename <- "back"
ratevars$multiplier <- 1
} else if (ratevars$multiplier == "cancel") {
ratevars$ratename <- "cancel"
ratevars$multiplier <- 1
mysettings$quit <- TRUE
step <- 20
}
}
ratevars$multiplier <- as.numeric(gsub(",", "", ratevars$multiplier))
# quality control - force selection of different numerator and denominator
# create a dialog specifically for this?
if (!exists("numerator", ratevars) | !exists("denominator", ratevars)) {
temp$msg <- "Please select different variables for numerator and denominator"
tcltk::tkmessageBox(title = "Please re-check variables", message = temp$msg,
type = "ok", icon = "warning")
ratevars$ratename <- "back"
} else if (ratevars$numerator == ratevars$denominator) {
temp$msg <- "Please reselect the numerator and denominator"
tcltk::tkmessageBox(title = "Please re-check variables", message = temp$msg,
type = "ok", icon = "warning")
ratevars$ratename <- "back"
}
}
if (ratevars$ratename == "back") {
step <- step - 1
} else if (!ratevars$ratename %in% c("back", "cancel") & !error) {
if (ratevars$ratename == "no_rate") {
temp$msg <- "You have chosen not to calculate a rate."
} else {
temp$msg <- paste0("You have chosen to calculate the rate ",
ratevars$ratename, " from ", ratevars$numerator,
" and ", ratevars$denominator, " with multiplier ",
format(as.numeric(ratevars$multiplier), big.mark=",",
scientific=FALSE),
" using the color scheme ", ratevars$colorname,
". Is this correct?")
}
temp$title <- "Confirm your rate calculation settings"
temp$x <- tcltk::tkmessageBox(title = temp$title, message = temp$msg,
type = "okcancel", icon = "question")
temp$confirm <- tcltk::tclvalue(temp$x)
if (temp$confirm == "ok") {
if (temp$flagconfirm) {
step <- 11
} else {
step <- step + 1
}
}
}
}
} else {
# message: wrong kind of shapefile; repeat dialog
temp$msg <- "There are not enough numeric variables to calculate a rate."
tcltk::tkmessageBox(title = "Rate calculation not possible", type = "ok",
icon = "warning", message = temp$msg)
if (temp$flagconfirm) {
step <- 11
} else {
step <- step + 1
}
ratevars <- list(ratename = "no_rate")
}
} # end request rate (ratevars)
while (step == 9) {
# add an option to save the KML file
pb <- list(title = "NYSDOH GAT: save KML?",
label = "Identifying whether to save a KML file.")
tcltk::setTkProgressBar(tpb, value = step, title = pb$title, label = pb$label)
temp$kml <- saveGATkml(step = step)
if (temp$kml == "Yes") {
gatvars$savekml <- TRUE # save the kml
if (temp$flagconfirm) {
step <- 11
} else {
step <- step + 1
}
} else if (temp$kml == "No") {
gatvars$savekml <- FALSE # do not save the kml
if (temp$flagconfirm) {
step <- 11
} else {
step <- step + 1
}
} else if (temp$kml == "quit") {
step <- 20
}else {
step <- step - 1
}
} # end request save KML (savekml)
while (step == 10) {
# identify the save files' name and location
pb <- list(title = "NYSDOH GAT: identify save file",
label = "Identifying the name and location of your save file.")
tcltk::setTkProgressBar(tpb, value = step, title = pb$title, label = pb$label)
saves <- saveGATfiles()
filevars$userout <- saves$userout
filevars$fileout <- saves$fileout
filevars$pathout <- saves$pathout
if (filevars$fileout == "cancel") {
mysettings$quit <- TRUE
step <- 20
} else {
step <- step + 1
}
} # end request save file (fileout)
while (step == 11) { # add dialog to confirm merge settings
pb <- list(title = "NYSDOH GAT: confirm settings",
label = "Confirming your GAT settings.")
tcltk::setTkProgressBar(tpb, value = step, title = pb$title,
label = pb$label)
temp$flagconfirm <- TRUE
error <- TRUE
gatvars$numrow <- nrow(temp$mapdata)
while (error) {
temp$cancel <- confirmGATbystep(gatvars = gatvars, ratevars = ratevars,
exclist = exclist, mergevars = mergevars,
filevars = filevars, step = step)
error <- FALSE
if (is.null(temp$cancel)) {
x <- confirmGATquit()
if (x == "quit") {
temp$cancel <- "Yes"
mysettings$quit <- TRUE
} else {
error <- TRUE
}
}
}
if (temp$cancel %in% c("Yes", "None")) {
step <- 20 # done with user input
} else if (temp$cancel == "back") {
step <- step - 1 # go back one
} else if (temp$cancel == "cancel") {
step <- 1 # if no, start again
} else if (grepl("[0-9]", temp$cancel)) {
step <- as.numeric(gsub("[^0-9]", "", temp$cancel))
}
} # end request settings confirmation (filein)
} # end while (step < 20)
rm(temp)
#     end user input ####
#  3. read in shapefile ####
step <- 14 # reset after the while loop
pb <- list(title = "NYSDOH GAT: processing the shapefile",
label = paste0("Reading in map from ", filevars$filein, "."))
tcltk::setTkProgressBar(tpb, value = step, title = pb$title, label = pb$label)
# reads map in as spatialpolygonsdataframe with projection information
myshps$original <- rgdal::readOGR(dsn = filevars$pathin,
layer = filevars$filein,
stringsAsFactors = FALSE)
myshps$original@data <- foreign::read.dbf(paste0(filevars$userin, ".dbf"),
as.is = TRUE) # maintains numerics
if ("GATy" %in% names(myshps$original@data)) {
myshps$original@data <- myshps$original@data[,
names(myshps$original@data)[!names(myshps$original@data) %in%
c("old_GATx", "old_GATy", "old_GATnumIDs", "old_GATcratio",
"old_GATflag")]]
for (i in 1: ncol(myshps$original@data)) {
# possibly these can be removed entirely, but need to verify
# if removing, inform user with warning dialog
# not sure how to handle flag variable - rename it?
if (names(myshps$original@data)[i] %in%
c("GATx", "GATy", "GATnumIDs", "GATcratio", "GATflag")) {
names(myshps$original@data)[i] <-
paste0("old_", names(myshps$original@data)[i])
}
}
}
# housekeeping
if (gatvars$aggregator2 == "NONE") {
gatvars$aggregator2 <- gatvars$aggregator1
}
rm(error)
gatvars$maxvalue1 <- as.numeric(gsub(",", "", gatvars$maxvalue1))
gatvars$maxvalue2 <- as.numeric(gsub(",", "", gatvars$maxvalue2))
gatvars$minvalue1 <- as.numeric(gsub(",", "", gatvars$minvalue1))
gatvars$minvalue2 <- as.numeric(gsub(",", "", gatvars$minvalue2))
if (gatvars$myidvar == "missing") {
myshps$original@data$temp_id <- paste0("ID_", 1:nrow(myshps$original@data))
gatvars$myidvar <- "temp_id"
}
myshps$original <- sp::spChFIDs(myshps$original,
myshps$original@data[, gatvars$myidvar])
# proj4string(myshp) # find if this map is lat/long or not (input projection)
mapvars <- list(projection = grepl("longlat",
sp::proj4string(myshps$original),
fixed = TRUE),  # returns logical vector
# suggested to avoid get.Pcent.
centroids = sp::coordinates(myshps$original))
colnames(mapvars$centroids) <- c("GATx", "GATy")
# if projection is lat/lon, projection = TRUE, otherwise FALSE
# default to not lat/long if something goes wrong
if (is.na(mapvars$projection)) mapvars$projection <- FALSE
# create a flag variable
myshps$original@data$GATflag <- 0 # all areas are included in the merge
# exclusions: for merge minimum violated, flag = 10
myshps$original@data$GATflag <- calculateGATflag(exclist, myshps$original@data)
myshps$original@data$GATflag <-
ifelse(myshps$original@data[, gatvars$aggregator1] > gatvars$maxvalue1, 5,
myshps$original@data$GATflag)
if (!gatvars$aggregator2 == gatvars$aggregator1) {
myshps$original@data$GATflag <-
ifelse(myshps$original@data[, gatvars$aggregator2] > gatvars$maxvalue2, 5,
myshps$original@data$GATflag)
}
#  4. run aggregation loop ####
step <- step + 1
pb$label = paste0("Aggregating ", filevars$filein, ".")
tcltk::setTkProgressBar(tpb, value = step, title = pb$title, label = pb$label)
gatvars$popwt <- mergevars$centroid == "population-weighted"
aggvars <- defineGATmerge(area = myshps$original, gatvars = gatvars,
mergevars = mergevars, filevars = filevars,
pwrepeat = pwrepeat, adjacent = adjacent)
#  5. aggregate areas ####
step <- step + 1
pb$label = paste("Completed", aggvars$newregno, "mergings.")
tcltk::setTkProgressBar(tpb, value = step, title = pb$title, label = pb$label)
myshps$aggregated <- mergeGATareas(ratevars = ratevars, aggvars = aggvars,
idvar = gatvars$myidvar,
myshp = myshps$original)
#  6. calculate compactness ratio ####
step <- step + 1
pb$label = "Checking compactness ratio."
tcltk::setTkProgressBar(tpb, value = step, title = pb$title, label = pb$label)
# to get maximum distance (diameter of circle): max(dist(test1))
temp <- list(cratio = calculateGATcompactness(myshps$aggregated),
ncol = ncol(myshps$aggregated))
myshps$compact <- maptools::spCbind(myshps$aggregated, temp$cratio)
names(myshps$compact)[temp$ncol+1] <- "GATcratio"
#  7. map first variable: before and after ####
step <- step + 1
pb <- list(title = "NYSDOH GAT: mapping variables",
label = paste0("Mapping ", gatvars$aggregator1, ". Please wait."))
tcltk::setTkProgressBar(tpb, value = step, title = pb$title, label = pb$label)
# create a list to record plots to be saved to pdf at the end.
myplots <- list()
# plot first aggregation variable
temp <- defineGATmapclasses(myshps$original, myshps$aggregated,
gatvars$aggregator1)
mapvars$title <- paste(gatvars$aggregator1, "Before Merging")
mapvars$colcode1before <- temp$colcode1before
mapvars$colcode1after <- temp$colcode1after
myplots$aggregator1before <- plotGATmaps(area = myshps$original,
var = gatvars$aggregator1,
title.main = mapvars$title,
colcode = mapvars$colcode1before,
mapstats = TRUE)
# find the new maximums after aggregation
mapvars$titlemain = paste(gatvars$aggregator1, "After Merging")
mapvars$titlesub = paste("Aggregation values:",
numformat(gatvars$minvalue1), "to",
numformat(as.numeric(gsub(",", "",
gatvars$maxvalue1))),
gatvars$aggregator1)
if (exclist$var1 != "NONE") {
mapvars$titlesub <- paste(mapvars$titlesub, "\nExclusion criteria: ",
exclist$var1, exclist$math1, numformat(exclist$val1))
}
if (exclist$var2 != "NONE") {
mapvars$titlesub <- paste(mapvars$titlesub, ";",
exclist$var2, exclist$math2,
numformat(exclist$val2))
}
if (exclist$var3 != "NONE") {
mapvars$titlesub <- paste(mapvars$titlesub, ";",
exclist$var3, exclist$math3,
numformat(exclist$val3))
}
myplots$aggregator1after <- plotGATmaps(area = myshps$aggregated,
var = gatvars$aggregator1,
title.main = mapvars$titlemain,
title.sub = mapvars$titlesub,
colcode = mapvars$colcode1after,
after = TRUE, mapstats = TRUE)
#  8. map second variable: before and after ####
step <- step + 1
if (!gatvars$aggregator2 %in% c("NONE", gatvars$aggregator1)) {
pb$label = paste("Mapping ", gatvars$aggregator2, ". Please wait.")
tcltk::setTkProgressBar(tpb, value = step, title = pb$title, label = pb$label)
# plot second aggregation variable, if relevant
temp <- defineGATmapclasses(myshps$original, myshps$aggregated,
gatvars$aggregator2)
mapvars$title <- paste(gatvars$aggregator2, "Before Merging")
mapvars$colcode2before <- temp$colcode2before
mapvars$colcode2after <- temp$colcode2after
myplots$aggregator2before <- plotGATmaps(area = myshps$original,
var = gatvars$aggregator2,
title.main = mapvars$title,
colcode = mapvars$colcode2before,
mapstats = TRUE)
mapvars$titlemain = paste(gatvars$aggregator2, "After Merging")
mapvars$titlesub = paste("Aggregation values:",
numformat(gatvars$minvalue2), "to",
numformat(as.numeric(gsub(",", "",
gatvars$maxvalue2))),
gatvars$aggregator2)
if (exclist$var1 != "NONE") {
mapvars$titlesub <- paste(mapvars$titlesub, "\nExclusion criteria: ",
exclist$var1, exclist$math1,
numformat(exclist$val1))
}
if (exclist$var2 != "NONE") {
mapvars$titlesub <- paste(mapvars$titlesub, ";", exclist$var2, exclist$math2,
numformat(exclist$val2))
}
if (exclist$var3 != "NONE") {
mapvars$titlesub <- paste(mapvars$titlesub, ";", exclist$var3, exclist$math3,
numformat(exclist$val3))
}
myplots$aggregator2after <- plotGATmaps(area = myshps$aggregated,
var = gatvars$aggregator2,
title.main = mapvars$titlemain,
title.sub = mapvars$titlesub,
colcode = mapvars$colcode2after,
after = TRUE, mapstats = TRUE)
}
#  9. map differences between old and new areas ####
step <- step + 1
pb$label = "Mapping differences before and after merging."
tcltk::setTkProgressBar(tpb, value = step, title = pb$title, label = pb$label)
# plot new and old on same map
myplots$compare <-  plotGATcompare(areaold = myshps$original,
areanew = myshps$aggregated,
mergevars = mergevars,
gatvars = gatvars)
# 10. map compactness ratio ####
step <- step + 1
pb$label = "Mapping compactness ratio after merging."
tcltk::setTkProgressBar(tpb, value = step, title = pb$title, label = pb$label)
# create thematic map of compactness ratios
gats <- list(title.main = "Compactness Ratio After Merging",
title.sub = "1=most compact, 0=least compact")
myplots$compactness <- plotGATmaps(area = myshps$compact,
var = "GATcratio", clr = "YlOrBr",
title.main = gats$title.main,
title.sub = gats$title.sub,
ratemap = TRUE)
# 11. map rates if needed ####
step <- step + 1
if (ratevars$ratename != "no_rate") { # map the rate, choropleth map
pb$label = paste0("Mapping rate variable ", ratevars$ratename, ".")
tcltk::setTkProgressBar(tpb, value = step, title = pb$title,
label = pb$label)
gats <- list(title = paste(ratevars$ratename, "per",
format(as.numeric(ratevars$multiplier),
big.mark = ",", scientific=FALSE),
"after merging"),
sub = paste("Rate calculation:", ratevars$ratename, "=",
format(as.numeric(ratevars$multiplier),
big.mark = ",", scientific=FALSE), "*",
ratevars$numerator, "/", ratevars$denominator))
if (exclist$var1 != "NONE") {
gats$sub <- paste(gats$sub, "\nExclusion criteria: ",
exclist$var1, exclist$math1,
format(exclist$val1, big.mark=",", scientific=FALSE))
}
if (exclist$var2 != "NONE") {
gats$sub <- paste(gats$sub, ";", exclist$var2, exclist$math2,
format(exclist$val2, big.mark=",", scientific=FALSE))
}
if (exclist$var3 != "NONE") {
gats$sub <- paste(gats$sub, ";", exclist$var3, exclist$math3,
format(exclist$val3, big.mark=",", scientific=FALSE))
}
myplots$rate <- plotGATmaps(area = myshps$aggregated, var = ratevars$ratename,
clr = ratevars$colorscheme,
title.sub = gats$sub,
title.main = gats$title, ratemap = TRUE,
mapstats = TRUE)
} # end mapping new rate
# 12. save old shapefile ####
step <- step + 1
pb <- list(title = "NYSDOH GAT: saving files",
label = paste("Writing the original shapfile to",
paste0(filevars$fileout, "in")))
tcltk::setTkProgressBar(tpb, value = step, title = pb$title, label = pb$label)
# create crosswalk of old and new ids
myshps$crosswalk <- myshps$original
myshps$crosswalk@data <- cbind(myshps$original@data,
data.frame(GATid = aggvars$IDlist))
# warnings don't make sense; they say data not written successfully,
# but shapefile is fine and data match original file
rgdal::writeOGR(myshps$crosswalk, filevars$pathout,
paste0(filevars$fileout, "in"),
driver = "ESRI Shapefile", verbose = TRUE,
overwrite_layer = TRUE)
# 13. save new shapefile ####
step <- step + 1
pb$label = paste("Writing the merged shapfile to", filevars$fileout)
tcltk::setTkProgressBar(tpb, value = step, title = pb$title, label = pb$label)
# export the map as a shapefile
rgdal::writeOGR(myshps$compact, filevars$pathout,
filevars$fileout, driver = "ESRI Shapefile",
verbose = TRUE, overwrite_layer = TRUE)
# large areas throw warnings that appear unfounded
# 14. save maps to pdf ####
step <- step + 1
pb$label = paste0("Writing the plots to ", filevars$fileout, "plots.pdf.")
tcltk::setTkProgressBar(tpb, value = step, title = pb$title,
label = pb$label)
# save the plots to a pdf file
pdf(paste0(filevars$userout, "plots.pdf"), onefile=TRUE, width = 10,
height = 7)
for (myplot in myplots) {
if (class(myplot) == "recordedplot") replayPlot(myplot)
} # only saves plots that exist
dev.off() # need to close pdf file
rm(myplots)
# 15. save kml file ####
if (gatvars$savekml==TRUE) { # now includes descriptions
step <- step + 1
pb$label = "Writing the KML file."
tcltk::setTkProgressBar(tpb, value = step, title = pb$title,
label = pb$label)
writeGATkml(myshp = myshps$compact, filename = filevars$fileout,
filepath = filevars$pathout, myidvar = gatvars$myidvar)
}
# 16. save log file ####
step <- step + 1
pb$label = paste0("Writing the log to ",
paste0(filevars$fileout, ".log"), ".")
tcltk::setTkProgressBar(tpb, value = step, title = pb$title, label = pb$label)
mysettings$exists = file.exists(paste0(filevars$userout, ".shp"))
# include projection? number of aggregations? rate calculations?
# recode to read in lists (or pre-create chunks) instead of individual values?
writeGATlog(gatvars = gatvars, aggvars = aggvars, filevars = filevars,
mysettings = mysettings, area = myshps$original,
mergevars = mergevars, ratevars = ratevars, exclist = exclist)
step <- step + 1
pb$label = "GAT is finished."
tcltk::setTkProgressBar(tpb, value = 27, title = pb$title, label = pb$label)
# save relevant objects
save(file = paste0(filevars$userout, "settings.Rdata"),
list = c("gatvars", "aggvars", "filevars", "mergevars", "ratevars",
"exclist"))
if (mysettings$exists) {
msg <- paste0("NYS GAT is finished. Your files were saved to ",
filevars$pathout,
". \nPlease see the log file for more details.")
tcltk::tkmessageBox(title = "GAT finished", type = "ok",
icon = "info", message = msg)
msg <- paste0("\n\nThe following files have been written to the folder \n",
filevars$pathout, ": \n  ",
filevars$fileout, ".dbf \n  ",
filevars$fileout, ".prj \n  ",
filevars$fileout, ".shp \n  ",
filevars$fileout, ".shx \n  ",
filevars$fileout, "in.dbf \n  ",
filevars$fileout, "in.prj \n  ",
filevars$fileout, "in.shp \n  ",
filevars$fileout, "in.shx \n  ",
filevars$fileout, "plots.pdf \n  ",
filevars$fileout, ".log \n  ",
filevars$fileout, "settings.Rdata \n  ")
if (gatvars$savekml==TRUE) msg <- paste0(msg, filevars$fileout, ".kml \n")
msg <- paste0(msg, "\nSee the log file for more details.")
message(msg)
} else {
# the shapefile failed to write
msg <- "Something went wrong. Your shapefiles were not saved."
tcltk::tkmessageBox(title = "Shapefile save failed", type = "ok",
icon = "error", message = msg)
}
devtools::check()
paste0(tools::getVignetteInfo("gatpkg", all = TRUE)[1, "Dir"], "/extdata/")
devtools::check()
devtools::build()
remove.packages("gatpkg", lib="~/R/win-library/3.6")
install.packages("P:/Sections/EHS/Abigail/SubcountyData/Rcode/gatpkg_1.41.tar.gz", repos = NULL, type = "source")
browseVignettes("gatpkg")
browseVignettes("gatpkg")
