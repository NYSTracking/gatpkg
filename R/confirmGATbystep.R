#' Confirm GAT Settings for Each Step
#'
#' @description
#' This function opens a dialog window for the user to select whether the
#' selected settings for GAT are correct. It provides the settings in list
#' format. The dialog window looks like this.
#'
#' \if{html}{\figure{confirmGATdialog.png}{options: width="395px"
#'                   alt="Figure: Screenshot of dialog to confirm your settings"}}
#'
#' Review your settings. Then click on one of the following buttons.
#'
#' * Click \code{Yes} to confirm the settings. In GAT, the next step is
#'   starting the aggregation process.
#' * Click \code{No} to reject the settings. In GAT, this returns you to step 1.
#'
#' @details
#' This function reads in the lists created during the user input portion of
#' the GAT tool. As such, it requires that the inputted lists contain the same
#' elements as those generated by the GAT tool.
#'
#' @param gatvars   A list of objects created by the GAT tool. It contains the
#'                  strings aggregator1, aggregator2, myidvar, and boundary and
#'                  the numbers minvalue1 and minvalue2.
#' @param ratevars  A list of objects needed to calculate rates. It contains
#'                  the strings ratename, numerator, and denominator and the
#'                  number multiplier.
#' @param mergevars A list of string objects needed to aggregate the areas in
#'                  GAT. It contains mergeopt1, similar1, and similar2.
#' @param exclist   A list of exclusion criteria to use when merging. It
#'                  contains strings representing the variables var1, var2,
#'                  and var3, and the conditions math1, math2, and math3, and
#'                  numbers representing cutoffs val1, val2, and val3 and the
#'                  number of excluded areas, flagsum.
#' @param filevars  The names of shapefiles to read in and the name of the
#'                  shapefile to save to, all without extensions.
#' @param savekml   A boolean, whether or not to save a KML file.
#' @param step      Integer step in the GAT program, for help reference.
#'
#### examples ####
#' @examples
#'
#' \donttest{
#' gatvars <-
#'   list(
#'     aggregator1 = "agg1",
#'     aggregator2 = "agg2",
#'     myidvar = "tract",
#'     minvalue1 = 5000,
#'     minvalue2 = 10000,
#'     maxvalue1 = 10000,
#'     maxvalue2 = 15000,
#'     boundary = "county",
#'     rigidbound = FALSE,
#'     popvar = "total_pop",
#'     savekml = TRUE,
#'     numrow = 15,
#'     exclmaxval = 2
#'   )
#'
#' mergevars <-
#'   list(
#'     mergeopt1 = "similar", # can be similar, closest, or least
#'     similar1 = "ratio1",
#'     similar2 = "ratio2",
#'     centroid = "geographic"
#'   )
#'
#' ratevars <-
#'   list(
#'     ratename = "my_rate",
#'     numerator = "case",
#'     denominator = "pop",
#'     multiplier = 100000,
#'     colorname = "Blue-Green"
#'   )
#'
#' exclist <-
#'   list(
#'     var1 = "exclusion1",
#'     var2 = "exclusion2",
#'     var3 = "NONE", # flag to denote no third variable
#'     math1 = "greater than",
#'     math2 = "less than",
#'     math3 = "equals",
#'     val1 = 10000,
#'     val2 = 50,
#'     val3 = 0,
#'     flagsum = 5
#'   )
#'
#' filevars <-
#'   list(
#'     filein = "hftown",
#'     popfile = "hfblock",
#'     fileout = "my_savefile",
#'     userin = "C:/users/default/shapefiles/hftown",
#'     userout = "C:/users/default/shapefiles/my_saves/my_savefile"
#'   )
#'
#' confirmGATbystep(
#'   gatvars = gatvars,
#'   ratevars = ratevars,
#'   mergevars = mergevars,
#'   exclist = exclist,
#'   filevars = filevars,
#'   step = 10
#' )
#' }
#'
#' @export
#### end roxygen ####

confirmGATbystep <- function(gatvars, ratevars, mergevars, filevars, exclist,
                             savekml, step = 0) {
  ## initial settings ####
  instruct <- paste("To modify a setting, choose it from the list and click",
                    "'Next >'. \n After you modify most settings, you will",
                    "return to this dialog. \n",
                    "If you modify setting 1, GAT will start over.")

  fonthead <- tcltk2::tk2font.set(font = "fonthead", settings = list(family = "Segoe UI",
                      size = 10, bold = TRUE, italic = FALSE))
  stepslist <- c("1. File to aggregate",
                 "2. Identifying variable",
                 "3. Boundary variable",
                 "4. Minimum and maximum values",
                 "5. Exclusion criteria",
                 "6. Merge type",
                 "7. Population file",
                 "8. Rate calculation",
                 "9. Save KML file",
                 "10. Save location",
                 "None")


  ## set up window ####
  tt <- tcltk::tktoplevel()
  tcltk::tktitle(tt) <- paste0("Step ", step, ": Review settings")

  ## define GAT settings ####
  mysets <- paste0("  ", stepslist[1], ": ", filevars$userin, " \n",
                   "  ", stepslist[2], ": ", gatvars$myidvar, " \n",
                   "  ", stepslist[3], ":")
  if (gatvars$boundary != "NONE") {
    mysets <- paste(mysets, gatvars$boundary)
    if (gatvars$rigidbound) {
      mysets <- paste(mysets, "required \n")
    } else {
      mysets <- paste(mysets, "not required \n")
    }
  } else {
    mysets <- paste(mysets, "None selected \n")
  }

  ### aggregation variables ####
  mysets <- paste0(mysets, "  ", stepslist[4], ": \n",
                   paste(rep(" ", 17), collapse = ""),
                   format(as.numeric(gsub(",", "", gatvars$minvalue1)),
                          big.mark=",", scientific=FALSE), " to ",
                   format(as.numeric(gsub(",", "", gatvars$maxvalue1)),
                          big.mark=",", scientific=FALSE), " ",
                   gatvars$aggregator1, "\n")
  if (!gatvars$aggregator2 %in% c(gatvars$aggregator1, "NONE")) {
    mysets <- paste(mysets, paste(rep(" ", 15), collapse = ""),
                    format(as.numeric(gsub(",", "", gatvars$minvalue2)), big.mark=",",
                           scientific=FALSE), "to",
                    format(as.numeric(gsub(",", "", gatvars$maxvalue2)),
                           big.mark=",", scientific=FALSE),
                    gatvars$aggregator2, "\n")
  }
  mysets <- paste(mysets, paste(rep(" ", 10), collapse = ""),
                  "Areas excluded (value over maximum):", gatvars$exclmaxval, "of",
                  gatvars$numrow, "\n")

  ### exclusions ####
  mysets <- paste0(mysets, "  ", stepslist[5], ":")
  if (exclist$var1 != "NONE" | exclist$var1 != "NONE" |
      exclist$var1 != "NONE") {
    if (exclist$var1 != "NONE") {
      mysets <- paste(mysets, exclist$var1, exclist$math1, exclist$val1, "\n")
    }
    if (exclist$var2 != "NONE") {
      mysets <- paste(mysets, paste(rep(" ", 36), collapse = ""),
                      exclist$var2, exclist$math2, exclist$val2, "\n")
    }
    if (exclist$var3 != "NONE") {
      mysets <- paste(mysets, paste(rep(" ", 36), collapse = ""),
                      exclist$var3, exclist$math3, exclist$val3, "\n")
    }
    mysets <- paste(mysets, paste(rep(" ", 10), collapse = ""),
                    "Areas excluded:", exclist$flagsum, "of", gatvars$numrow, "\n")
  } else {
    mysets <- paste(mysets, "None selected \n")
  }

  ### merge type ####
  mysets <- paste0(mysets, "  ", stepslist[6], ":")
  if (mergevars$mergeopt1 == "closest") {
    mysets <- paste(mysets, "Closest", mergevars$centroid, "centroid \n")
  } else if (mergevars$mergeopt1 == "least") {
    mysets <- paste(mysets, "Adjacent area with the fewest", gatvars$aggregator1, "\n")
  } else if (mergevars$mergeopt1 == "similar") {
    mysets <- paste(mysets, "Adjacent area with the closest value of \n",
                    paste(rep(" ", 27), collapse = ""),
                    mergevars$similar1, "/", mergevars$similar2, "\n")
  }

  ### population weighting ####
  mysets <- paste0(mysets, "  ", stepslist[7], ":")
  if (mergevars$centroid == "population-weighted") {
    mysets <- paste(mysets, filevars$popfile, "\n",
                    paste(rep(" ", 10), collapse = ""),
                    "Population variable:", gatvars$popvar, "\n")
  } else {
    mysets <- paste(mysets, "Population weighting not selected \n")
  }

  ### rate settings ####
  mysets <- paste0(mysets, "  ", stepslist[8], ":")
  if (ratevars$ratename == "no_rate") {
    mysets <- paste(mysets, "Not selected \n")
  } else {
    mysets <- paste(mysets, ratevars$ratename, "=",
                    format(as.numeric(ratevars$multiplier), big.mark=",",
                           scientific=FALSE),
                    "*", ratevars$numerator, "/", ratevars$denominator, "\n",
                    paste(rep(" ", 10), collapse = ""),
                    "Color scheme:", ratevars$colorname, "\n")
  }

  ### save kml ####
  mysets <- paste0(mysets, "  ", stepslist[9], "?")
  if (gatvars$savekml) {
    mysets <- paste(mysets, "Yes \n")
  } else {
    mysets <- paste(mysets, "No \n")
  }

  ### save location ####
  mysets <- paste0(mysets, stepslist[10], ": ", filevars$userout)

  ## print GAT settings ####
  tt$ins <- tcltk2::tk2label(tt, text = mysets)
  tcltk::tkgrid(tt$ins, sticky = "w", padx = 5, pady = 5)
  tt$insttl <- tcltk2::tk2label(tt, text = "Instructions", font = "fonthead")
  tcltk::tkgrid(tt$insttl, sticky = "w", padx = 5, pady = 5)
  tt$ins <- tcltk2::tk2label(tt, text = instruct)
  tcltk::tkgrid(tt$ins, sticky = "w", padx = 5, pady = 5)

  ## request step selection ####
  tt$stepdir <- tcltk::tkframe(tt)
  stepvar <- tcltk::tclVar("None")
  tt$stepdir$stepq <- tcltk2::tk2label(tt$stepdir,
                      text = "Select the setting you wish to modify:")
  tt$stepdir$steplist <- tcltk::ttkcombobox(tt$stepdir, values = stepslist,
                         textvariable = stepvar, state = "readonly")
  tcltk::tkgrid(tt$stepdir$stepq, tt$stepdir$steplist, sticky = "w",
                padx = 5, pady = 5)
  tcltk::tkgrid(tt$stepdir)

  ## help settings ####
  helppage <- "confirmGATlist"
  hlp <- paste0("To continue, select a setting to modify,",
                " or 'Finished' if you are done, then click 'Next >',",
                 "\nto start over, click 'Start Over',",
                 "\nand to return to save file location, click '< Back',")

  myenv <- new.env()
  # button functions and layout
  onHelp <- function() {
    showGAThelp(help = hlp, helptitle = helppage, helppage = helppage,
                step = step)
  }
  onOk <- function() {
    Rbval <- tcltk::tclvalue(stepvar)
    tcltk::tkdestroy(tt)
    assign("myvalue", Rbval, envir=myenv)
  }
  onCancel <- function() {
    tcltk::tkdestroy(tt)
    assign("myvalue", "cancel", envir=myenv)
  }

  # draw buttons
  tt$tf <- tcltk::tkframe(tt)
  tt$tf$HelpBut <- tcltk2::tk2button(tt$tf, text="Help",
                                     width = 12, command = onHelp)
  tt$tf$OkBut <- tcltk2::tk2button(tt$tf, text = "Confirm",
                                   width = 12, command = onOk,
                                   default = "active")
  tt$tf$CancelBut <- tcltk2::tk2button(tt$tf, text = "Cancel GAT",
                                       width = 12, command = onCancel)

  tcltk::tkgrid(tt$tf$OkBut, column = 2, row = 1, padx = 5)
  tcltk::tkgrid(tt$tf$CancelBut, column = 3, row = 1, padx = 5)
  tcltk::tkgrid(tt$tf$HelpBut, column = 4, row = 1, padx = 5)
  tcltk::tkgrid(tt$tf, padx = 1, pady = 5)

  # wait to continue ####
  tcltk::tkwait.window(tt)
  return(myenv$myvalue)
}
